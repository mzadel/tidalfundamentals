

## See also

Live code with Tidal Cycles | Tidal Cycles
https://tidalcycles.org/

Types in tidal-cycles
https://www.imn.htwk-leipzig.de/~waldmann/etc/untutorial/tc/types/

What is a pattern? - TidalCycles userbase
https://userbase.tidalcycles.org/index.php/What_is_a_pattern%3F

Tidal Adventures. Introduction | by Carsten Heisterkamp | Medium
https://heisterkamp.medium.com/tidal-adventures-ab627f05ef7c

tidal: Pattern language for improvised music
https://hackage.haskell.org/package/tidal




## Installing the tidal haskell libraries

MacOS | Tidal Cycles
https://tidalcycles.org/docs/getting-started/macos_install

 - I used stack to make a locally-contained install
     - Stack (Haskell) - Wikipedia https://en.wikipedia.org/wiki/Stack_(Haskell)
 - Install using the instructions here:
     - https://haskellstack.org
     - https://docs.haskellstack.org/en/stable/install_and_upgrade/
 - Can blow away `~/.stack` to reset your install
 - Run `stack setup`
     - Will download the latest LTS version of GHC
     - Can be checked in `~/.stack/global-project/stack.yaml`: `resolver: lts-18.13`
     - Go to stackage and click on LTS at the top to check the most recent stable version
     - Ends up in `~/.stack/programs/x86_64-osx/ghc-8.10.7/bin/ghc`
         - See `stack path`
     - Invoke as `stack ghc` or `stack ghci`
 - Then install tidal haskell library with `stack install tidal`
     - Not enough to make sound, but enough to play with the types
     - Sound needs supercollider, the superdirt supercollider plugin, text editor support (Atom, Emacs, Vim...)


## Sanity checking the basic tidal install

    $ stack ghci

    Note: No local targets specified, so a plain ghci will be started with no package hiding
          or package options.

          You are using snapshot: lts-18.13

          If you want to use package hiding and options, then you can try one of the
          following:

          * If you want to start a different project configuration
            than /.../.stack/global-project/stack.yaml, then you can use stack init to
            create a new stack.yaml for the packages in the current directory.

          * If you want to use the project configuration
            at /.../.stack/global-project/stack.yaml, then you can add to its 'packages' field.

    Configuring GHCi with the following packages:
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded GHCi configuration from /private/var/folders/ny/rrw1ccy54sxdp2rv844cxx0rqv33h5/T/haskell-stack-ghci/2a3bbd58/ghci-script
    Prelude> import Sound.Tidal.Context
    Prelude Sound.Tidal.Context> tidal_version
    "1.7.8"



## Starting to look at some expressions

This seems to work in the examples but not in ghci:

    Prelude Sound.Tidal.Context> s $ "bd bd bd"

    <interactive>:14:5: error:
        • Couldn't match expected type ‘Pattern String’
                      with actual type ‘[Char]’
        • In the second argument of ‘($)’, namely ‘"bd bd bd"’
          In the expression: s $ "bd bd bd"
          In an equation for ‘it’: it = s $ "bd bd bd"

It needs parseBP_E, which is automatically, silently added when running from the text editor.  In a normal ghci:

    Prelude Sound.Tidal.Context> s $ parseBP_E "bd bd bd"
    (0>⅓)|s: "bd"
    (⅓>⅔)|s: "bd"
    (⅔>1)|s: "bd"

You can turn on the implict string handling with {-# language OverloadedStrings #-}, or the equivalent :set -XOverloadedStrings in ghci (see waldmann article above).

    $ stack ghci
    ...
    Configuring GHCi with the following packages:
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded GHCi configuration from /private/var/folders/ny/rrw1ccy54sxdp2rv844cxx0rqv33h5/T/haskell-stack-ghci/2a3bbd58/ghci-script
    Prelude> import Sound.Tidal.Context
    Prelude Sound.Tidal.Context> :set -XOverloadedStrings
    Prelude Sound.Tidal.Context> s $ "bd bd bd"
    (0>⅓)|s: "bd"
    (⅓>⅔)|s: "bd"
    (⅔>1)|s: "bd"

OverloadedStrings is described at https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/overloaded_strings.html .
I'd prefer not to use it right now since I'm explicitly trying to figure out the types and to understand the core definitions.



## Pattern type

    Prelude Sound.Tidal.Context> a = s $ parseBP_E "m n o"
    Prelude Sound.Tidal.Context> a
    (0>⅓)|s: "m"
    (⅓>⅔)|s: "n"
    (⅔>1)|s: "o"
    Prelude Sound.Tidal.Context> :t a
    a :: ControlPattern

m n o is arbitrary here.  There's a mini pattern language that's used in the string literal that's parsed by parseBP_E.

"m n o" takes one bar (ie one cycle) and divides it into three, and each one is
an event.

Pattern is defined in Sound/Tidal/Pattern.hs .

    -- | A datatype representing events taking place over time
    data Pattern a = Pattern {query :: State -> [Event a]}
      deriving (Generic, Functor)

So a pattern is something that can be queried, returning a list of events.

The idea is that a pattern divides a cycle evenly into event windows with data
attached to each one.  You can query a time range of the pattern to see which
event windows it overlaps.

An arc goes from one time to another.  Time is expressed as a rational (i.e., a fraction)  (defined in Sound/Tidal/Time.hs)

    -- | Time is rational
    type Time = Rational

    -- | An arc of time, with a start time (or onset) and a stop time (or offset)
    data ArcF a = Arc
      { start :: a
      , stop :: a
      } deriving (Eq, Ord, Functor, Show, Generic)

    type Arc = ArcF Time

The reason it's called an arc is that a cycle is imagined to lie on a circle.  An arc is a portion of that circle.

So we can create an arc of time:

    Prelude Sound.Tidal.Context> arcoftime = Arc 0.5 1.2
    Prelude Sound.Tidal.Context> arcoftime
    Arc {start = 0.5, stop = 1.2}

And then query our pattern:

    Prelude Sound.Tidal.Context> import qualified Data.Map.Strict as Map
    Prelude Sound.Tidal.Context Map> query a (State arcoftime Map.empty)
    [[((1,1),(2,1))](1>1⅕)-1⅓|s: "m",[((3,1),(4,1))]⅓-(½>⅔)|s: "n",[((5,1),(6,1))](⅔>1)|s: "o"]

A smaller window that overlaps only the first event:

    Prelude Sound.Tidal.Context Map> query a (State (Arc 0 1/6) Map.empty)
    [[((1,1),(2,1))](0>⅙)-⅓|s: "m"]
    Prelude Sound.Tidal.Context Map> :t query a (State (Arc 0 1/6) Map.empty)
    query a (State (Arc 0 1/6) Map.empty) :: [Event ValueMap]

So we're getting a list of events from the query.  Each event contains a ValueMap.

## Event type

If we just take the first event:

    Prelude Sound.Tidal.Context Map> head $ query a $ State (Arc 0 1/6) Map.empty
    [((1,1),(2,1))](0>⅙)-⅓|s: "m"

Let's pull the event apart.  The event has this type (see Sound/Tidal/Pattern.hs):

    -- | An event is a value that's active during a timespan. If a whole
    -- is present, the part should be equal to or fit inside it.
    data EventF a b = Event
      { context :: Context
      , whole :: Maybe a
      , part :: a
      , value :: b
      } deriving (Eq, Ord, Functor, Generic)
    instance (NFData a, NFData b) => NFData (EventF a b)

    type Event a = EventF (ArcF Time) a

so

    Prelude Sound.Tidal.Context Map> firstevent = head $ query a $ State (Arc 0 1/6) Map.empty
    Prelude Sound.Tidal.Context Map> value firstevent
    s: "m"
    Prelude Sound.Tidal.Context Map> whole firstevent
    Just 0>⅓
    Prelude Sound.Tidal.Context Map> part firstevent
    0>⅙
    Prelude Sound.Tidal.Context Map> context firstevent
    [((1,1),(2,1))]

The value is from the string we passed into the initial string expression (s $ parseBP_E "m n o")

The whole is the entire span of the event that our little window overlaps.
(The whole event goes from 0 to one third, our window goes from zero to one
sixth.)

The context is apparently the position within the sourcecode, I guess used when
interpreting expressions in a live coding context.

So if we overlap the first two events and get the second event:

    Prelude Sound.Tidal.Context Map> firstevent:secondevent:others = query a $ State (Arc (1/6) (3/6)) Map.empty
    Prelude Sound.Tidal.Context Map> firstevent
    [((1,1),(2,1))]0-(⅙>⅓)|s: "m"
    Prelude Sound.Tidal.Context Map> whole firstevent
    Just 0>⅓
    Prelude Sound.Tidal.Context Map> part firstevent
    ⅙>⅓
    Prelude Sound.Tidal.Context Map> secondevent
    [((3,1),(4,1))](⅓>½)-⅔|s: "n"
    Prelude Sound.Tidal.Context Map> whole secondevent
    Just ⅓>⅔
    Prelude Sound.Tidal.Context Map> part secondevent
    ⅓>½

So it looks like the way to interpret (⅓>½)-⅔ is

    (⅓>½) is the part, where the query window overlaps with the event window
    ⅓ to ⅔ is the whole event window
    and (⅓>½)-⅔ is a representation that combines both the partial window from the query and the whole event window

And then s: "n" is the key-value pair from the ValueMap .

There are some functions to query the window start / ends:

    Prelude Sound.Tidal.Context Map> wholeStart firstevent
    0 % 1
    Prelude Sound.Tidal.Context Map> wholeStop firstevent
    1 % 3
    Prelude Sound.Tidal.Context Map> eventPartStart firstevent
    1 % 6
    Prelude Sound.Tidal.Context Map> eventPartStop firstevent
    1 % 3
    Prelude Sound.Tidal.Context Map> eventValue firstevent
    s: "m"

I'm not sure if these functions are typically used.  They're probably internal.


## You don't need the s function to examine the internals

You can omit the s function, which is an alias for sound (see Params.hs).
But is seems to only accept certain letters then:

    Prelude Sound.Tidal.Context> parseBP_E "t r s"
    *** Exception: Syntax error in sequence:
      "t r s"
       ^
    unexpected 't'
    expecting white space, "-", "+", number, "c", "d", "e", "f", "g", "a", "b", "'", rest, "[", "{", "<", "^", ".", "?" or end of input

I guess s somehow makes the string mini-language accept more tokens.  But anyway, this works:

    Prelude Sound.Tidal.Context> parseBP_E "a e g"
    (0>⅓)|9
    (⅓>⅔)|4
    (⅔>1)|7

## Defining and showing patterns

You can use the output as above, or drawLine:

    Prelude Sound.Tidal.Context> parseBP_E "a b c"
    (0>⅓)|9
    (⅓>⅔)|11
    (⅔>1)|0
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a b c"

    [19 cycles]
    |abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc

See https://tidalcycles.org/docs/patternlib/tutorials/mini_notation for notes
on the syntax of the following examples.

Tilde is a rest:

    Prelude Sound.Tidal.Context> s $ parseBP_E "bd ~ bd ~"
    (0>¼)|s: "bd"
    (½>¾)|s: "bd"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "bd ~ bd ~"

    [11 cycles]
    |bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.

So the dot in the drawLine output is the rest.

Underscore elongates a note:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a _ c"
    (0>⅔)|s: "a"
    (⅔>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a _ c"

    [19 cycles]
    |a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c

The hyphen means that the a note is held for an extra division.

Repeat an event with * . Notice how it takes the time the event would have taken and subdivides that:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a*2 c"
    (0>¼)|s: "a"
    (¼>½)|s: "a"
    (½>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a*2 c"

    [15 cycles]
    |aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-

So instead of getting the cycle divided into three, it's divided into four.


Use ! to repeat an event.  Contrast this with * .

    Prelude Sound.Tidal.Context> s $ parseBP_E "a!2 c"
    (0>⅓)|s: "a"
    (⅓>⅔)|s: "a"
    (⅔>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a!2 c"

    [19 cycles]
    |aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac

Use square brackets for grouping.

    Prelude Sound.Tidal.Context> s $ parseBP_E "[a b c] [d e]"
    (0>⅙)|s: "a"
    (⅙>⅓)|s: "b"
    (⅓>½)|s: "c"
    (½>¾)|s: "d"
    (¾>1)|s: "e"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "[a b c] [d e]"

    [6 cycles]
    |a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--

So it divided the pattern into two halves, and then divided the first half into
three and the second half into two.

You can do the same with a dot:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a b c . d e"
    (0>⅙)|s: "a"
    (⅙>⅓)|s: "b"
    (⅓>½)|s: "c"
    (½>¾)|s: "d"
    (¾>1)|s: "e"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a b c . d e"

    [6 cycles]
    |a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--


So this is where I think it starts to get interesting.
Use a comma to play two patterns in parallel.  Apparently you need the square brackets as well.

    Prelude Sound.Tidal.Context> s $ parseBP_E "[a b c , d e]"
    (0>⅓)|s: "a"
    (0>½)|s: "d"
    (⅓>⅔)|s: "b"
    (½>1)|s: "e"
    (⅔>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "[a b c , d e]"

    [11 cycles]
    |a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-
    |d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--

I'm officially feeling this.
The first expression's output orders the events by onset time.

You can create polymetric sequences with braces:

    Prelude Sound.Tidal.Context> s $ parseBP_E "{a b c , d e}"
    (0>⅓)|s: "a"
    (0>⅓)|s: "d"
    (⅓>⅔)|s: "b"
    (⅓>⅔)|s: "e"
    (⅔>1)|s: "c"
    (⅔>1)|s: "d"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "{a b c , d e}"

    [19 cycles]
    |abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc
    |ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded

So it looks like it takes the first pattern and divides the cycle by the number
of elements it has, and then uses that length for each element of the second
pattern.

Contrast with doing it in the other order:

    Prelude Sound.Tidal.Context> s $ parseBP_E "{d e , a b c}"
    (0>½)|s: "d"
    (0>½)|s: "a"
    (½>1)|s: "e"
    (½>1)|s: "b"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "{d e , a b c}"

    [26 cycles]
    |de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de
    |ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca

It doesn't show the c in the first expression since I guess it only queries it
over one cycle.

You can set the length of the polymetric sequence with %  . The first pair of
expressions divide the cycle in to eight, and the second pair divide the cycle
into seven.

    Prelude Sound.Tidal.Context> s $ parseBP_E "{a b c d e}%8"
    (0>⅛)|s: "a"
    (⅛>¼)|s: "b"
    (¼>⅜)|s: "c"
    (⅜>½)|s: "d"
    (½>⅝)|s: "e"
    (⅝>¾)|s: "a"
    (¾>⅞)|s: "b"
    (⅞>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "{a b c d e}%8"

    [8 cycles]
    |abcdeabc|deabcdea|bcdeabcd|eabcdeab|cdeabcde|abcdeabc|deabcdea|bcdeabcd
    Prelude Sound.Tidal.Context> s $ parseBP_E "{a b c d e}%7"
      (0>⅐)|s: "a"
     (⅐>²₇)|s: "b"
    (²₇>³₇)|s: "c"
    (³₇>⁴₇)|s: "d"
    (⁴₇>⁵₇)|s: "e"
    (⁵₇>⁶₇)|s: "a"
     (⁶₇>1)|s: "b"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "{a b c d e}%7"

    [9 cycles]
    |abcdeab|cdeabcd|eabcdea|bcdeabc|deabcde|abcdeab|cdeabcd|eabcdea|bcdeabc

Use angle brackets to alternate between the events

    Prelude Sound.Tidal.Context> s $ parseBP_E "<a b c> d <e f>"
    (0>⅓)|s: "a"
    (⅓>⅔)|s: "d"
    (⅔>1)|s: "e"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "<a b c> d <e f>"

    [19 cycles]
    |ade|bdf|cde|adf|bde|cdf|ade|bdf|cde|adf|bde|cdf|ade|bdf|cde|adf|bde|cdf|ade

Use brackets to create a Euclidean rhythm:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a(3,7)"
      (0>⅐)|s: "a"
    (²₇>³₇)|s: "a"
    (⁴₇>⁵₇)|s: "a"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a(3,7)"

    [9 cycles]
    |a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..



