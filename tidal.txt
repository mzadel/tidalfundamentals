---
title: 'Learning Tidal'
author: 'Mark Zadel'
date: 'October 2021'

fontsize: 12pt
monobackgroundcolor: 'LightGrey'
header-includes: |
  <style>
  body {
    max-width: 60em;
  }
  img {
    max-width: none;
  }
  </style>
---

These are the notes I made when trying to first understand tidal's data model.
This isn't about making sound!  It's about trying to fundamentally understand
the expressions and values to have a good basis going forward.

## See also

Live code with Tidal Cycles | Tidal Cycles<br/>
<https://tidalcycles.org/>

Types in tidal-cycles<br/>
<https://www.imn.htwk-leipzig.de/~waldmann/etc/untutorial/tc/types/>

What is a pattern? - TidalCycles userbase<br/>
<https://userbase.tidalcycles.org/index.php/What_is_a_pattern%3F>

Tidal Adventures. Introduction | by Carsten Heisterkamp | Medium<br/>
<https://heisterkamp.medium.com/tidal-adventures-ab627f05ef7c>

tidal: Pattern language for improvised music<br/>
<https://hackage.haskell.org/package/tidal>



## Installing the tidal library in haskell

MacOS | Tidal Cycles<br/>
<https://tidalcycles.org/docs/getting-started/macos_install>

### Install via cabal

I tried installing a few different times in a few different ways, and
the method I preferred was the following:

 - used `ghcup` (<https://www.haskell.org/ghcup/>)
     - installed `ghc` with `ghcup`
     - added `$HOME/.ghcup/bin:$HOME/.ghcup/ghc/8.10.7/bin` to `$PATH` in `.bashrc`
     - installed `cabal` with `ghcup`
     - `cabal update`
     - `cabal install tidal --lib`

NB: THIS IS NOT SUFFICIENT TO MAKE SOUND!!  I'm only interested in
executing expressions and inspecting types at this stage.  Look at
the installation instructions on <tidalcycles.org> for installing
SuperCollider, SuperDirt and a compatible text editor, which are all
required for a typical install.

I initially had linker errors when compiling haskell code.  What I
had to do was uninstall ghc and cabal, uninstall all of my homebrew
programs, reinstall ghc and cabal, and then it worked.  (It was fine
to reinstall homebrew for me since there was a lot of cruft left
around that I'd just kept upgrading over several years and OS
versions.)

Even with the linker errors, I could still use `runhaskell` to run
the code.

The `--lib` part is important.  That makes it possible to run `import
Sound.Tidal.Context` in `ghci`.

You can delete `.ghc`, `.ghcup` and `.cabal` to start over from
scratch if you're trying to debug install problems.

### Alternative: install via stack

You can also use stack:

 - Run `stack setup`
     - Will download the latest LTS version of GHC
     - The LTS resolver version can be checked in `~/.stack/global-project/stack.yaml`: `resolver: lts-18.13`
     - Go to <https://www.stackage.org> and click on LTS at the top to check the most recent stable version
     - Ends up in `~/.stack/programs/x86_64-osx/ghc-8.10.7/bin/ghc`
         - See `stack path`
     - Invoke as `stack ghc` or `stack ghci`
 - `stack install --no-library-stripping tidal`

You can blow away `~/.stack` to reset your install for
fixing installation problems.

`--no-library-stripping` is important, since it's needed to import
tidal inside a `ghci` sessoin.

### Installing diagrams (optional, not needed for tidal)

I also installed `diagrams` for making the diagrams.  (You don't need
to do this.)

 - with cabal
     - `cabal install diagrams-core --lib`
     - `cabal install diagrams-lib --lib`
     - `cabal install diagrams-svg --lib`
     - `cabal install palette --lib`
 - with stack
     - change your stack install to a nightly instead of LTS.  The
       LTS one doesn't include diagrams for some reason.
     - `stack install --no-library-stripping diagrams-core`
     - `stack install --no-library-stripping diagrams-lib`
     - `stack install --no-library-stripping diagrams-svg`
     - `stack install --no-library-stripping palette`

I couldn't install the top-level `diagrams` library since I don't
think it worked with the `--lib` flag.  (I might have to confirm that
detail, though.)




## Sanity checking the basic tidal install

    $ ghci
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    Prelude> import Sound.Tidal.Context
    Prelude Sound.Tidal.Context> tidal_version
    "1.7.8"


## Starting to look at some expressions

This seems to work in the online examples but not in ghci:

    Prelude Sound.Tidal.Context> s $ "bd bd bd"

    <interactive>:14:5: error:
        • Couldn't match expected type ‘Pattern String’
                      with actual type ‘[Char]’
        • In the second argument of ‘($)’, namely ‘"bd bd bd"’
          In the expression: s $ "bd bd bd"
          In an equation for ‘it’: it = s $ "bd bd bd"

It needs `parseBP_E`, which is automatically, silently added when running from the text editor.  In a normal `ghci`:

    Prelude Sound.Tidal.Context> s $ parseBP_E "bd bd bd"
    (0>⅓)|s: "bd"
    (⅓>⅔)|s: "bd"
    (⅔>1)|s: "bd"

You can turn on the implict string handling with `{-# language OverloadedStrings #-}`, or the equivalent `:set -XOverloadedStrings` in `ghci` (see waldmann article above).

    $ ghci
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    Prelude> import Sound.Tidal.Context
    Prelude Sound.Tidal.Context> :set -XOverloadedStrings
    Prelude Sound.Tidal.Context> s $ "bd bd bd"
    (0>⅓)|s: "bd"
    (⅓>⅔)|s: "bd"
    (⅔>1)|s: "bd"

`OverloadedStrings` is described at <https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/overloaded_strings.html> .
I'd prefer not to use it right now since I'm explicitly trying to figure out the types and to understand the core definitions.



## Pattern type

    Prelude Sound.Tidal.Context> a = s $ parseBP_E "m n o"
    Prelude Sound.Tidal.Context> a
    (0>⅓)|s: "m"
    (⅓>⅔)|s: "n"
    (⅔>1)|s: "o"
    Prelude Sound.Tidal.Context> :t a
    a :: ControlPattern

m n o is arbitrary here.  There's a mini pattern language that's used in the string literal that's parsed by `parseBP_E`.

"m n o" takes one bar (ie one cycle) and divides it into three, and each one is
an event.

![](mnocycle.svg)

`Pattern` is defined in `Sound/Tidal/Pattern.hs`.

    -- | A datatype representing events taking place over time
    data Pattern a = Pattern {query :: State -> [Event a]}
      deriving (Generic, Functor)

So a pattern is something that can be queried, returning a list of events.

The idea is that a pattern divides a cycle evenly into event windows with data
attached to each one.  You can query a time range of the pattern to see which
event windows it overlaps.

An arc goes from one time to another.  Time is expressed as a rational (i.e., a fraction)  (defined in `Sound/Tidal/Time.hs`)

    -- | Time is rational
    type Time = Rational

    -- | An arc of time, with a start time (or onset) and a stop time (or offset)
    data ArcF a = Arc
      { start :: a
      , stop :: a
      } deriving (Eq, Ord, Functor, Show, Generic)

    type Arc = ArcF Time

The reason it's called an arc is that a cycle is imagined to lie on a circle.  An arc is a portion of that circle.

So we can create an arc of time:

    Prelude Sound.Tidal.Context> arcoftime = Arc 0.5 1.2
    Prelude Sound.Tidal.Context> arcoftime
    Arc {start = 0.5, stop = 1.2}

And then query our pattern:

    Prelude Sound.Tidal.Context> a = s $ parseBP_E "m n o"
    Prelude Sound.Tidal.Context> arcoftime = Arc 0.5 1.2
    Prelude Sound.Tidal.Context> import qualified Data.Map.Strict as Map
    Prelude Sound.Tidal.Context Map> query a (State arcoftime Map.empty)
    [[((1,1),(2,1))](1>1⅕)-1⅓|s: "m",[((3,1),(4,1))]⅓-(½>⅔)|s: "n",[((5,1),(6,1))](⅔>1)|s: "o"]

A smaller window that overlaps only the first event:

    Prelude Sound.Tidal.Context Map> query a (State (Arc 0 1/6) Map.empty)
    [[((1,1),(2,1))](0>⅙)-⅓|s: "m"]
    Prelude Sound.Tidal.Context Map> :t query a (State (Arc 0 1/6) Map.empty)
    query a (State (Arc 0 1/6) Map.empty) :: [Event ValueMap]

So we're getting a list of events from the query.  Each event contains a `ValueMap`.

## Event type

If we just take the first event:

    Prelude Sound.Tidal.Context Map> head $ query a $ State (Arc 0 1/6) Map.empty
    [((1,1),(2,1))](0>⅙)-⅓|s: "m"

Let's pull the event apart.  The event has this type (see `Sound/Tidal/Pattern.hs`):

    -- | An event is a value that's active during a timespan. If a whole
    -- is present, the part should be equal to or fit inside it.
    data EventF a b = Event
      { context :: Context
      , whole :: Maybe a
      , part :: a
      , value :: b
      } deriving (Eq, Ord, Functor, Generic)
    instance (NFData a, NFData b) => NFData (EventF a b)

    type Event a = EventF (ArcF Time) a

so

    Prelude Sound.Tidal.Context Map> firstevent = head $ query a $ State (Arc 0 1/6) Map.empty
    Prelude Sound.Tidal.Context Map> value firstevent
    s: "m"
    Prelude Sound.Tidal.Context Map> whole firstevent
    Just 0>⅓
    Prelude Sound.Tidal.Context Map> part firstevent
    0>⅙
    Prelude Sound.Tidal.Context Map> context firstevent
    [((1,1),(2,1))]

The value is from the string we passed into the initial string expression (`s $ parseBP_E "m n o"`)

The whole is the entire span of the event that our little window overlaps.
(The whole event goes from 0 to one third, our window goes from zero to one
sixth.)

The context is apparently the position within the sourcecode, I guess used when
interpreting expressions in a live coding context.

So if we overlap the first two events and get the second event:

    Prelude Sound.Tidal.Context Map> firstevent:secondevent:others = query a $ State (Arc (1/6) (3/6)) Map.empty
    Prelude Sound.Tidal.Context Map> firstevent
    [((1,1),(2,1))]0-(⅙>⅓)|s: "m"
    Prelude Sound.Tidal.Context Map> whole firstevent
    Just 0>⅓
    Prelude Sound.Tidal.Context Map> part firstevent
    ⅙>⅓
    Prelude Sound.Tidal.Context Map> secondevent
    [((3,1),(4,1))](⅓>½)-⅔|s: "n"
    Prelude Sound.Tidal.Context Map> whole secondevent
    Just ⅓>⅔
    Prelude Sound.Tidal.Context Map> part secondevent
    ⅓>½

So it looks like the way to interpret (⅓>½)-⅔ is

 - (⅓>½) is the part, where the query window overlaps with the event window
 - ⅓ to ⅔ is the whole event window
 - and (⅓>½)-⅔ is a representation that combines both the partial window from the query and the whole event window

And then s: "n" is the key-value pair from the `ValueMap`.

There are some functions to query the window start / ends:

    Prelude Sound.Tidal.Context Map> wholeStart firstevent
    0 % 1
    Prelude Sound.Tidal.Context Map> wholeStop firstevent
    1 % 3
    Prelude Sound.Tidal.Context Map> eventPartStart firstevent
    1 % 6
    Prelude Sound.Tidal.Context Map> eventPartStop firstevent
    1 % 3
    Prelude Sound.Tidal.Context Map> eventValue firstevent
    s: "m"

I'm not sure if these functions are typically used.  They're probably internal.


## You don't need the s function to examine the internals

You can omit the s function, which is an alias for sound (see `Params.hs`).
But is seems to only accept certain letters then:

    Prelude Sound.Tidal.Context> parseBP_E "t r s"
    *** Exception: Syntax error in sequence:
      "t r s"
       ^
    unexpected 't'
    expecting white space, "-", "+", number, "c", "d", "e", "f", "g", "a", "b", "'", rest, "[", "{", "<", "^", ".", "?" or end of input

I guess `s` somehow makes the string mini-language accept more tokens.  But anyway, this works:

    Prelude Sound.Tidal.Context> parseBP_E "a e g"
    (0>⅓)|9
    (⅓>⅔)|4
    (⅔>1)|7

## Defining and showing patterns

You can use the output as above, or `drawLine`:

    Prelude Sound.Tidal.Context> parseBP_E "a b c"
    (0>⅓)|9
    (⅓>⅔)|11
    (⅔>1)|0
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a b c"

    [19 cycles]
    |abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc

![](basicpattern.svg)

See <https://tidalcycles.org/docs/patternlib/tutorials/mini_notation> for notes
on the syntax of the following examples.

--------------------------------------------------

Tilde is a rest:

    Prelude Sound.Tidal.Context> s $ parseBP_E "bd ~ bd ~"
    (0>¼)|s: "bd"
    (½>¾)|s: "bd"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "bd ~ bd ~"

    [11 cycles]
    |bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.|bd.bd.

So the dot in the `drawLine` output is the rest.

![](tildeisarest.svg)

--------------------------------------------------

Underscore elongates a note:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a _ c"
    (0>⅔)|s: "a"
    (⅔>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a _ c"

    [19 cycles]
    |a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c|a-c

The hyphen means that the a note is held for an extra division.

![](underscoreelongates.svg)

--------------------------------------------------

`@` elongates a pattern by some number of counts:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a@3 b"
    (0>¾)|s: "a"
    (¾>1)|s: "b"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a@3 b"

    [15 cycles]
    |a--b|a--b|a--b|a--b|a--b|a--b|a--b|a--b|a--b|a--b|a--b|a--b|a--b|a--b|a--b

![](atelongates.svg)

--------------------------------------------------

Repeat an event with * . Notice how it takes the time the event would have taken and subdivides that:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a*2 c"
    (0>¼)|s: "a"
    (¼>½)|s: "a"
    (½>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a*2 c"

    [15 cycles]
    |aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-|aac-

![](repeateventasterisk.svg)

So instead of getting the cycle divided into three, it's divided into four.

The 'a' events have duration 1/4.

--------------------------------------------------

Use ! to repeat an event.  Contrast this with * .

    Prelude Sound.Tidal.Context> s $ parseBP_E "a!2 c"
    (0>⅓)|s: "a"
    (⅓>⅔)|s: "a"
    (⅔>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a!2 c"

    [19 cycles]
    |aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac|aac

![](repeateventbang.svg)

The 'a' events have duration 1/3 here.

--------------------------------------------------

Use square brackets for grouping.

    Prelude Sound.Tidal.Context> s $ parseBP_E "[a b c] [d e]"
    (0>⅙)|s: "a"
    (⅙>⅓)|s: "b"
    (⅓>½)|s: "c"
    (½>¾)|s: "d"
    (¾>1)|s: "e"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "[a b c] [d e]"

    [6 cycles]
    |a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--

So it divided the pattern into two halves, and then divided the first half into
three and the second half into two.

![](squarebrackets.svg)

--------------------------------------------------

You can do the same with a dot:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a b c . d e"
    (0>⅙)|s: "a"
    (⅙>⅓)|s: "b"
    (⅓>½)|s: "c"
    (½>¾)|s: "d"
    (¾>1)|s: "e"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a b c . d e"

    [6 cycles]
    |a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--|a-b-c-d--e--

![](thedot.svg)

--------------------------------------------------

So this is where I think it starts to get interesting.
Use a comma to play two patterns in parallel.  Apparently you need the square brackets as well.

    Prelude Sound.Tidal.Context> s $ parseBP_E "[a b c , d e]"
    (0>⅓)|s: "a"
    (0>½)|s: "d"
    (⅓>⅔)|s: "b"
    (½>1)|s: "e"
    (⅔>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "[a b c , d e]"

    [11 cycles]
    |a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-|a-b-c-
    |d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--|d--e--

I'm officially feeling this.

The first expression's output orders the interleaved events by onset time.

![](commaforparallel.svg)

--------------------------------------------------

You can create polymetric sequences with braces:

    Prelude Sound.Tidal.Context> s $ parseBP_E "{a b c , d e}"
    (0>⅓)|s: "a"
    (0>⅓)|s: "d"
    (⅓>⅔)|s: "b"
    (⅓>⅔)|s: "e"
    (⅔>1)|s: "c"
    (⅔>1)|s: "d"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "{a b c , d e}"

    [19 cycles]
    |abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc|abc
    |ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded|ede|ded

![](polymetricbraces.svg)

So it looks like it takes the first pattern and divides the cycle by the number
of elements it has, and then uses that length for each element of the second
pattern.

Contrast with doing it in the other order:

    Prelude Sound.Tidal.Context> s $ parseBP_E "{d e , a b c}"
    (0>½)|s: "d"
    (0>½)|s: "a"
    (½>1)|s: "e"
    (½>1)|s: "b"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "{d e , a b c}"

    [26 cycles]
    |de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de|de
    |ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca|bc|ab|ca

![](polymetricbracesotherorder.svg)

So in this second version, the 'a b c' events have a longer duration:
putting the "d e" first divides the cycle in two, and so the "a b c" pattern
repeats every 1.5 cycles.

The vertical bar in the text output seems to show a one-cycle duration.

--------------------------------------------------

You can set the length of the polymetric sequence with `%`.

This expression divides the cycle into eight

    Prelude Sound.Tidal.Context> s $ parseBP_E "{a b c d e}%8"
    (0>⅛)|s: "a"
    (⅛>¼)|s: "b"
    (¼>⅜)|s: "c"
    (⅜>½)|s: "d"
    (½>⅝)|s: "e"
    (⅝>¾)|s: "a"
    (¾>⅞)|s: "b"
    (⅞>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "{a b c d e}%8"

    [8 cycles]
    |abcdeabc|deabcdea|bcdeabcd|eabcdeab|cdeabcde|abcdeabc|deabcdea|bcdeabcd

![](polymetricdividebyeight.svg)

This expression divides the cycle into seven.

    Prelude Sound.Tidal.Context> s $ parseBP_E "{a b c d e}%7"
      (0>⅐)|s: "a"
     (⅐>²₇)|s: "b"
    (²₇>³₇)|s: "c"
    (³₇>⁴₇)|s: "d"
    (⁴₇>⁵₇)|s: "e"
    (⁵₇>⁶₇)|s: "a"
     (⁶₇>1)|s: "b"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "{a b c d e}%7"

    [9 cycles]
    |abcdeab|cdeabcd|eabcdea|bcdeabc|deabcde|abcdeab|cdeabcd|eabcdea|bcdeabc

![](polymetricdividebyseven.svg)

--------------------------------------------------

Use angle brackets to alternate between the events

    Prelude Sound.Tidal.Context> s $ parseBP_E "<a b c> d <e f>"
    (0>⅓)|s: "a"
    (⅓>⅔)|s: "d"
    (⅔>1)|s: "e"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "<a b c> d <e f>"

    [19 cycles]
    |ade|bdf|cde|adf|bde|cdf|ade|bdf|cde|adf|bde|cdf|ade|bdf|cde|adf|bde|cdf|ade

![](anglebrackets.svg)

--------------------------------------------------

Use brackets to create a Euclidean rhythm:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a(3,7)"
      (0>⅐)|s: "a"
    (²₇>³₇)|s: "a"
    (⁴₇>⁵₇)|s: "a"
    Prelude Sound.Tidal.Context> drawLine $ parseBP_E "a(3,7)"

    [9 cycles]
    |a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..|a.a.a..

![](euclideanrhythm.svg)


## Standard library functions

What we've seen above is the pattern "mini-language".  There are also a lot of pattern functions in the standard libarary.

There is documentation online starting at <https://tidalcycles.org/docs/patternlib/tour/concatenation>.  (See "Small Reference" at the left.)

I'll start to play with some of the basic ones here to understand what they're doing.

--------------------------------------------------

`slow` elongates (i.e., slows down) a pattern

    Prelude Sound.Tidal.Context> s $ slow 2 $ parseBP_E "a a b c"
    (0>½)|s: "a"
    (½>1)|s: "a"
    Prelude Sound.Tidal.Context> drawLine $ slow 2 $ parseBP_E "a a b c"

    [26 cycles]
    |aa|bc|aa|bc|aa|bc|aa|bc|aa|bc|aa|bc|aa|bc|aa|bc|aa|bc|aa|bc|aa|bc|aa|bc|aa|bc

![](slowfunction.svg)

### Digression: querying across cycle boundaries

Interestingly, `slow` seems to query results on cycle boundaries:

    Prelude Sound.Tidal.Context> s $ slow 1.5 $ parseBP_E "a a b c"
       (0>⅜)|s: "a"
       (⅜>¾)|s: "a"
    (¾>1)-1⅛|s: "b"
    Prelude Sound.Tidal.Context> drawLine $ slow 1.5 $ parseBP_E "a a b c"

    [8 cycles]
    |a--a--b-|b---a--a|a----c--|a--a--b-|b---a--a|a----c--|a--a--b-|b---a--a

![](slowoneandahalf.svg)

(I'm using `queryArc` and `part` to make the diagrams, so it shows up there as well.)

Using `queryArc` to ask for the events:

    Prelude Sound.Tidal.Context> queryArc (s $ slow 1.5 $ parseBP_E "a a b c") (Arc 0 3)
    [[((1,1),(2,1))](0>⅜)|s: "a",[((3,1),(4,1))](⅜>¾)|s: "a",[((5,1),(6,1))](¾>1)-1⅛|s: "b",[((1,1),(2,1))](1½>1⅞)|s: "a",[((3,1),(4,1))](1⅞>2)-2¼|s: "a",[((5,1),(6,1))]¾-(1>1⅛)|s: "b",[((7,1),(8,1))](1⅛>1½)|s: "c",[((3,1),(4,1))]1⅞-(2>2¼)|s: "a",[((5,1),(6,1))](2¼>2⅝)|s: "b",[((7,1),(8,1))](2⅝>3)|s: "c"]

Pulling this apart (manually) and sorting (manually) we get

    (0>⅜)|s: "a"
    (⅜>¾)|s: "a"
    (¾>1)-1⅛|s: "b"
    ¾-(1>1⅛)|s: "b"
    (1⅛>1½)|s: "c"
    (1½>1⅞)|s: "a"
    (1⅞>2)-2¼|s: "a"
    1⅞-(2>2¼)|s: "a"
    (2¼>2⅝)|s: "b"
    (2⅝>3)|s: "c"

![](slowoneandahalfoneeighthticks.svg)

So it looks like the query is giving back two parts for the first "b" event since it crosses a cycle boundary

 - (¾>1)-1⅛|s: "b"
 - ¾-(1>1⅛)|s: "b"

but note that for both `Event`s the `whole` is the same: (¾>1⅛).  (*This* is
why I take the time to understand how to read the output of these functions...)
I think it'll still only play the one note even though the result of `queryArc`
seems 'wrong' here.

So query windows seem to be split at cycle boundaries.
I'm going to chalk this up to an implementation detail and not worry about it
too much right now.  (That'll teach me - use round numbers!)

I just found `showAll`, which gives the same info

    Prelude Sound.Tidal.Context> import Sound.Tidal.Show
    Prelude Sound.Tidal.Context Sound.Tidal.Show> putStrLn $ showAll (Arc 0 3) $ s $ slow 1.5 $ parseBP_E "a a b c"
    [((1,1),(2,1))](0>⅜)|s: "a"
    [((3,1),(4,1))](⅜>¾)|s: "a"
    [((5,1),(6,1))](¾>1)-1⅛|s: "b"
    [((5,1),(6,1))]¾-(1>1⅛)|s: "b"
    [((7,1),(8,1))](1⅛>1½)|s: "c"
    [((1,1),(2,1))](1½>1⅞)|s: "a"
    [((3,1),(4,1))](1⅞>2)-2¼|s: "a"
    [((3,1),(4,1))]1⅞-(2>2¼)|s: "a"
    [((5,1),(6,1))](2¼>2⅝)|s: "b"
    [((7,1),(8,1))](2⅝>3)|s: "c"

Meh, I should just drop it.

### Back to our regularly scheduled program

`fast` speeds things up

    Prelude Sound.Tidal.Context> s $ fast 3 $ parseBP_E "a b c"
      (0>⅑)|s: "a"
     (⅑>²₉)|s: "b"
     (²₉>⅓)|s: "c"
     (⅓>⁴₉)|s: "a"
    (⁴₉>⁵₉)|s: "b"
     (⁵₉>⅔)|s: "c"
     (⅔>⁷₉)|s: "a"
    (⁷₉>⁸₉)|s: "b"
     (⁸₉>1)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ fast 3 $ parseBP_E "a b c"

    [7 cycles]
    |abcabcabc|abcabcabc|abcabcabc|abcabcabc|abcabcabc|abcabcabc|abcabcabc


![](fastfunction.svg)

--------------------------------------------------

`fastGap` speeds things up but aligns to the cycle

    Prelude Sound.Tidal.Context> s $ fastGap 3 $ parseBP_E "a b c"
     (0>⅑)|s: "a"
    (⅑>²₉)|s: "b"
    (²₉>⅓)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ fastGap 3 $ parseBP_E "a b c"

    [7 cycles]
    |abc......|abc......|abc......|abc......|abc......|abc......|abc......

![](fastgapfunction.svg)

--------------------------------------------------

`compress` squeezes a pattern into a given arc of time

    Prelude Sound.Tidal.Context> s $ compress (1/4,1/2) $ parseBP_E "a b c"
       (¼>⅓)|s: "a"
    (⅓>5/12)|s: "b"
    (5/12>½)|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ compress (1/4,1/2) $ parseBP_E "a b c"

    [6 cycles]
    |...abc......|...abc......|...abc......|...abc......|...abc......|...abc......

![](compressfunction.svg)

--------------------------------------------------

`zoom` zooms in on a portion of a pattern.  It maps the zoomed portion to the
duration of the input pattern.

    Prelude Sound.Tidal.Context> s $ zoom (1/4,3/4) $ parseBP_E "a b c"
    -1½-(0>⅙)|s: "a"
        (⅙>⅚)|s: "b"
     (⅚>1)-1½|s: "c"
    Prelude Sound.Tidal.Context> drawLine $ zoom (1/4,3/4) $ parseBP_E "a b c"

    [11 cycles]

    |a----c|a----c|a----c|a----c|a----c|a----c|a----c|a----c|a----c|a----c|a----c


![](zoomfunction.svg)

(I don't know why the "b" event isn't shown in the `drawLine` output above.)


--------------------------------------------------

`rev` reverses each cycle of a pattern

    Prelude Sound.Tidal.Context> s $ rev $ slow 2 $ parseBP_E "a ~ b ~ ~ c"
    (0>⅓)|s: "b"
    (⅔>1)|s: "a"
    Prelude Sound.Tidal.Context> drawLine $ rev $ slow 2 $ parseBP_E "a ~ b ~ ~ c"

    [19 cycles]
    |b.a|c..|b.a|c..|b.a|c..|b.a|c..|b.a|c..|b.a|c..|b.a|c..|b.a|c..|b.a|c..|b.a

Input (`slow 2 $ parseBP_E "a ~ b ~ ~ c"`):
![](revfunctioninput.svg)
Output (`rev $ slow 2 $ parseBP_E "a ~ b ~ ~ c"`):
![](revfunctionoutput.svg)




## Pattern types

`Pattern` has a type parameter that specifies the kind of data contained in
each event:

    Prelude Sound.Tidal.Context> :k Pattern
    Pattern :: * -> *

    -- | A datatype representing events taking place over time
    data Pattern a = Pattern {query :: State -> [Event a]}

The basic `parseBP_E` function goes from a string to a pattern without a
concrete type variable:

    Prelude Sound.Tidal.Context> :t parseBP_E
    parseBP_E :: (Enumerable a, Parseable a) => String -> Pattern a
    Prelude Sound.Tidal.Context> parseBP_E "a b c d"
    (0>¼)|9
    (¼>½)|11
    (½>¾)|0
    (¾>1)|2
    Prelude Sound.Tidal.Context> :t parseBP_E "a b c d"
    parseBP_E "a b c d" :: (Enumerable a, Parseable a) => Pattern a


You can define a pattern containing events which contain various basic types by
giving the expression the concrete type:

    Prelude Sound.Tidal.Context> parseBP_E "1 2 3" :: Pattern Double
    (0>⅓)|1.0
    (⅓>⅔)|2.0
    (⅔>1)|3.0
    Prelude Sound.Tidal.Context> :t parseBP_E "1 2 3" :: Pattern Double
    parseBP_E "1 2 3" :: Pattern Double :: Pattern Double
    Prelude Sound.Tidal.Context> parseBP_E "1 2 3" :: Pattern Char
    (0>⅓)|'1'
    (⅓>⅔)|'2'
    (⅔>1)|'3'
    Prelude Sound.Tidal.Context> :t parseBP_E "1 2 3" :: Pattern Char
    parseBP_E "1 2 3" :: Pattern Char :: Pattern Char
    Prelude Sound.Tidal.Context> parseBP_E "1 2 3" :: Pattern Int
    (0>⅓)|1
    (⅓>⅔)|2
    (⅔>1)|3
    Prelude Sound.Tidal.Context> :t parseBP_E "1 2 3" :: Pattern Int
    parseBP_E "1 2 3" :: Pattern Int :: Pattern Int

## Pattern algebra

There's an "algebra" of patterns where you can combine them with various
operations, and it'll combine the individual events in some appropriate and
natural way.

The `(|+)` operator is addition, taking structure from the left (`src/Sound/Tidal/Core.hs`).

    Prelude Sound.Tidal.Context> parseBP_E "1 2 3" |+ parseBP_E "20 40" :: Pattern Double
      (0>⅓)|21.0
    (⅓>½)-⅔|22.0
    ⅓-(½>⅔)|42.0
      (⅔>1)|43.0

![](leftPlusExample1.svg)

(In the text output, notice that the "22" and the "42" entries correspond to
the same whole event.  I'm taking this to mean that the value changes midway
though the event, but the onset still happens at the "22" in this case.)

    Prelude Sound.Tidal.Context> parseBP_E "1 2 3" |+ parseBP_E "20 40 60" :: Pattern Double
    (0>⅓)|21.0
    (⅓>⅔)|42.0
    (⅔>1)|63.0

![](leftPlusExample2.svg)

    Prelude Sound.Tidal.Context> parseBP_E "1 2 3" |+ parseBP_E "20 40 60 80" :: Pattern Double
    (0>¼)-⅓|21.0
    0-(¼>⅓)|41.0
    (⅓>½)-⅔|42.0
    ⅓-(½>⅔)|62.0
    (⅔>¾)-1|63.0
    ⅔-(¾>1)|83.0

![](leftPlusExample3.svg)

--------------------------------------------------

The `+|` operator does addition, but takes the events from the right argument:

![](rightPlusExample1.svg)
![](rightPlusExample2.svg)
![](rightPlusExample3.svg)

--------------------------------------------------

The `|+|` operator does addition, but takes the events from both arguments:

![](bothPlusExample1.svg)
![](bothPlusExample2.svg)
![](bothPlusExample3.svg)

--------------------------------------------------

If you use `+`, it's like `|+|`:

![](justPlusExample1.svg)

--------------------------------------------------

There are a bunch of operators that work in the same way documented
at <https://tidalcycles.org/docs/patternlib/tutorials/pattern_structure>.


## More pattern types

The `s` that we have been using is an alias for `sound`, which I guess selects
a sound sample from the set of named samples.  It's defined in
`src/Sound/Tidal/Params.hs`.

    sound :: Pattern String -> ControlPattern
    sound = grp [mS "s", mF "n"]

    s :: Pattern String -> ControlPattern
    s = sound

A `ControlPattern` is a pattern that contains events with a map of values in
them.  It is defined in `src/Sound/Tidal/Pattern.hs`

    type ControlPattern = Pattern ValueMap

    type ValueMap = Map.Map String Value

So `sound` contains a string "s" parameter and a float "n" parameter.
I believe it's the sound name and the note/sample number.
(So for e.g. bass drum samples, there are several bass drums to choose from.)

    Prelude Sound.Tidal.Context> :t sound
    sound :: Pattern String -> ControlPattern
    Prelude Sound.Tidal.Context> :t s
    s :: Pattern String -> ControlPattern

    Prelude Sound.Tidal.Context> :t sound . parseBP_E
    sound . parseBP_E :: String -> ControlPattern
    Prelude Sound.Tidal.Context> sound $ parseBP_E "a b c d"
    (0>¼)|s: "a"
    (¼>½)|s: "b"
    (½>¾)|s: "c"
    (¾>1)|s: "d"
    Prelude Sound.Tidal.Context> :t sound $ parseBP_E "a b c d"
    sound $ parseBP_E "a b c d" :: ControlPattern

There's also `n` (`src/Sound/Tidal/Params.hs`):

    -- | The note or sample number to choose for a synth or sampleset
    n :: Pattern Note -> ControlPattern
    n = pN "n"

(I started to chase these functions around but it got kind of hairy for my
level of understanding.  I'll have to live with trying to understand things
from the code comments.)

    Prelude Sound.Tidal.Context> :t n . parseBP_E
    n . parseBP_E :: String -> ControlPattern
    Prelude Sound.Tidal.Context> n $ parseBP_E "1 2 3 4"
    (0>¼)|n: Note {unNote = 1.0}n
    (¼>½)|n: Note {unNote = 2.0}n
    (½>¾)|n: Note {unNote = 3.0}n
    (¾>1)|n: Note {unNote = 4.0}n
    Prelude Sound.Tidal.Context> :t n $ parseBP_E "1 2 3 4"
    n $ parseBP_E "1 2 3 4" :: ControlPattern

(I think `unNote` is the field name that you would call to extract the float
value from a note.)

So I think what you can do is combine `sound` and `n` patterns into one
`ControlPattern`.  So starting with these expressions:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a b c d"
    (0>¼)|s: "a"
    (¼>½)|s: "b"
    (½>¾)|s: "c"
    (¾>1)|s: "d"
    Prelude Sound.Tidal.Context> :t s $ parseBP_E "a b c d"
    s $ parseBP_E "a b c d" :: ControlPattern
    Prelude Sound.Tidal.Context> n $ parseBP_E "1 2 3 4"
    (0>¼)|n: Note {unNote = 1.0}n
    (¼>½)|n: Note {unNote = 2.0}n
    (½>¾)|n: Note {unNote = 3.0}n
    (¾>1)|n: Note {unNote = 4.0}n
    Prelude Sound.Tidal.Context> :t n $ parseBP_E "1 2 3 4"
    n $ parseBP_E "1 2 3 4" :: ControlPattern

here are two ways to do the set the note number for each event:

    Prelude Sound.Tidal.Context> s $ parseBP_E "a:1 b:2 c:3 d:4"
    (0>¼)|n: 1.0f, s: "a"
    (¼>½)|n: 2.0f, s: "b"
    (½>¾)|n: 3.0f, s: "c"
    (¾>1)|n: 4.0f, s: "d"
    Prelude Sound.Tidal.Context> :t s $ parseBP_E "a:1 b:2 c:3 d:4"
    s $ parseBP_E "a:1 b:2 c:3 d:4" :: ControlPattern
    Prelude Sound.Tidal.Context> (s $ parseBP_E "a b c d") |> (n $ parseBP_E "1 2 3 4")
    (0>¼)|n: Note {unNote = 1.0}n, s: "a"
    (¼>½)|n: Note {unNote = 2.0}n, s: "b"
    (½>¾)|n: Note {unNote = 3.0}n, s: "c"
    (¾>1)|n: Note {unNote = 4.0}n, s: "d"
    Prelude Sound.Tidal.Context> :t (s $ parseBP_E "a b c d") |> (n $ parseBP_E "1 2 3 4")
    (s $ parseBP_E "a b c d") |> (n $ parseBP_E "1 2 3 4")
      :: Pattern ValueMap

It seems to me that these are equivalent since `type ControlPattern = Pattern ValueMap`.

## Booting Tidal from ghci

You can actually boot a live tidal from ghci and get a prompt:

    $ ghci
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    Prelude> :script BootTidal.hs
    [TidalCycles version 1.7.8]
    Installed in /.../.cabal/store/ghc-8.10.7/tdl-1.7.8-5d5b197d/share
    Listening for external controls on 127.0.0.1:6010
    tidal> Waiting for SuperDirt (v.1.7.2 or higher)..

    tidal>
    tidal> s "a b c"
    (0>⅓)|s: "a"
    (⅓>⅔)|s: "b"
    (⅔>1)|s: "c"

Either run `ghci` and then `:script BootTidal.hs`, or run
`ghci -ghci-script BootTidal.hs`.


# Inspecting OSC

You can use `oscdump` from `liblo` to see what messages are coming in:

    $ ./oscdump 57120

Then in the tidal repl:

    $ ghci -ghci-script BootTidal.hs
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    [TidalCycles version 1.7.8]
    Installed in /.../.cabal/store/ghc-8.10.7/tdl-1.7.8-5d5b197d/share
    Listening for external controls on 127.0.0.1:6010
    Loaded GHCi configuration from BootTidal.hs
    tidal> Waiting for SuperDirt (v.1.7.2 or higher)..

    tidal>
    tidal> d1 $ s "bd"

You see in the running `oscdump`:

    e520f7d6.950bd000 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 47.000000 "delta" 1.777778 "orbit" 0 "s" "bd"
    e520f7d6.faaf9a8b /dirt/handshake
    e520f7d8.5c284800 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 48.000000 "delta" 1.777778 "orbit" 0 "s" "bd"
    e520f7d8.fae3e6c3 /dirt/handshake


Another example:

    tidal> d1 $ s "bd" + (n "1 2 3")

    in oscdump:
    e520f856.950bd000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 119.000000 "delta" 0.592593 "n" 1.000000 "orbit" 0 "s" "bd"
    e520f857.26c8a372 /dirt/handshake
    e520f857.2cbff800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 119.333336 "delta" 0.592593 "n" 2.000000 "orbit" 0 "s" "bd"
    e520f857.c4742000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 119.666664 "delta" 0.592593 "n" 3.000000 "orbit" 0 "s" "bd"
    e520f858.5c284800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 120.000000 "delta" 0.592592 "n" 1.000000 "orbit" 0 "s" "bd"
    e520f858.f3dc6800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 120.333336 "delta" 0.592593 "n" 2.000000 "orbit" 0 "s" "bd"
    e520f859.2854de7e /dirt/handshake
    e520f859.8b909000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 120.666664 "delta" 0.592593 "n" 3.000000 "orbit" 0 "s" "bd"

So this would be a good way to understand how patterns are played and what's
the result of combining patterns.

