---
title: 'Learning Tidal'
author: 'Mark Zadel'
date: 'October 2021'

fontsize: 12pt
monobackgroundcolor: 'LightGrey'
header-includes: |
  <style>
  body {
    max-width: 60em;
  }
  img {
    max-width: none;
  }
  </style>
---

These are the notes I made when trying to first understand tidal's data model.
This isn't about making sound!  It's about trying to fundamentally understand
the expressions and values to have a good basis going forward.

## See also

Live code with Tidal Cycles | Tidal Cycles<br/>
<https://tidalcycles.org/>

Types in tidal-cycles<br/>
<https://www.imn.htwk-leipzig.de/~waldmann/etc/untutorial/tc/types/>

What is a pattern? - TidalCycles userbase<br/>
<https://userbase.tidalcycles.org/index.php/What_is_a_pattern%3F>

Tidal Adventures. Introduction | by Carsten Heisterkamp | Medium<br/>
<https://heisterkamp.medium.com/tidal-adventures-ab627f05ef7c>

tidal: Pattern language for improvised music<br/>
<https://hackage.haskell.org/package/tidal>



## Installing the tidal library in haskell

MacOS | Tidal Cycles<br/>
<https://tidalcycles.org/docs/getting-started/macos_install>

### Install via cabal

I tried installing a few different times in a few different ways, and
the method I preferred was the following:

 - used `ghcup` (<https://www.haskell.org/ghcup/>)
     - installed `ghc` with `ghcup`
     - added `$HOME/.ghcup/bin:$HOME/.ghcup/ghc/8.10.7/bin` to `$PATH` in `.bashrc`
     - installed `cabal` with `ghcup`
     - `cabal update`
     - `cabal install tidal --lib`

NB: THIS IS NOT SUFFICIENT TO MAKE SOUND!!  I'm only interested in
executing expressions and inspecting types at this stage.  Look at
the installation instructions on
[tidalcycles.org](https://tidalcycles.org) for installing
SuperCollider, SuperDirt and a compatible text editor, which are all
required for a typical install.

I initially had linker errors when compiling haskell code.  What I
had to do was uninstall ghc and cabal, uninstall all of my homebrew
programs, reinstall ghc and cabal, and then it worked.  (It was fine
to reinstall homebrew for me since there was a lot of cruft left
around that I'd just kept upgrading over several years and OS
versions.)

Even with the linker errors, I could still use `runhaskell` to run
the code.

The `--lib` part is important.  That makes it possible to run `import
Sound.Tidal.Context` in `ghci`.

You can delete `.ghc`, `.ghcup` and `.cabal` to start over from
scratch if you're trying to debug install problems.

### Alternative: install via stack

You can also use stack:

 - Run `stack setup`
     - Will download the latest LTS version of GHC
     - The LTS resolver version can be checked in `~/.stack/global-project/stack.yaml`: `resolver: lts-18.13`
     - Go to <https://www.stackage.org> and click on LTS at the top to check the most recent stable version
     - Ends up in `~/.stack/programs/x86_64-osx/ghc-8.10.7/bin/ghc`
         - See `stack path`
     - Invoke as `stack ghc` or `stack ghci`
 - `stack install --no-library-stripping tidal`

You can blow away `~/.stack` to reset your install for
fixing installation problems.

`--no-library-stripping` is important, since it's needed to import
tidal inside a `ghci` sessoin.

### Installing diagrams (optional, not needed for tidal)

I also installed `diagrams` for making the diagrams.  (You don't need
to do this.)

 - with cabal
     - `cabal install diagrams-core --lib`
     - `cabal install diagrams-lib --lib`
     - `cabal install diagrams-svg --lib`
     - `cabal install palette --lib`
 - with stack
     - change your stack install to a nightly instead of LTS.  The
       LTS one doesn't include diagrams for some reason.
     - `stack install --no-library-stripping diagrams-core`
     - `stack install --no-library-stripping diagrams-lib`
     - `stack install --no-library-stripping diagrams-svg`
     - `stack install --no-library-stripping palette`

I couldn't install the top-level `diagrams` library since I don't
think it worked with the `--lib` flag.  (I might have to confirm that
detail, though.)




## Sanity checking the basic tidal install

    $ ghci
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    Prelude> import Sound.Tidal.Context
    Prelude Sound.Tidal.Context> tidal_version
    "1.7.8"


## Starting to look at some expressions

This seems to work in the online examples but not in ghci:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
s $ "bd bd bd"
~~~

It needs `parseBP_E`, which is automatically, silently added when running from the text editor.  In a normal `ghci`:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
s $ parseBP_E "bd bd bd"
~~~

You can turn on the implict string handling with `{-# language OverloadedStrings #-}`, or the equivalent `:set -XOverloadedStrings` in `ghci` (see waldmann article above).

~~~{.ghcisession}
import Sound.Tidal.Context
:set -XOverloadedStrings
s $ "bd bd bd"
~~~

`OverloadedStrings` is described at <https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/overloaded_strings.html> .
I'd prefer not to use it right now since I'm explicitly trying to figure out the types and to understand the core definitions.



## Pattern type

~~~{.ghcisession #mnocycle tidalexpression='s $ parseBP_E "m n o"' .diagram}
import Sound.Tidal.Context
--cut>>
a = {{tidalexpression}}
a
:t a
~~~

m n o is arbitrary here.  There's a mini pattern language that's used in the string literal that's parsed by `parseBP_E`.

"m n o" takes one bar (ie one cycle) and divides it into three, and each one is
an event.

![](mnocycle.svg)

`Pattern` is defined in `Sound/Tidal/Pattern.hs`.

    -- | A datatype representing events taking place over time
    data Pattern a = Pattern {query :: State -> [Event a]}
      deriving (Generic, Functor)

So a pattern is something that can be queried, returning a list of events.

The idea is that a pattern divides a cycle evenly into event windows with data
attached to each one.  You can query a time range of the pattern to see which
event windows it overlaps.

An arc goes from one time to another.  Time is expressed as a rational (i.e., a fraction)  (defined in `Sound/Tidal/Time.hs`)

    -- | Time is rational
    type Time = Rational

    -- | An arc of time, with a start time (or onset) and a stop time (or offset)
    data ArcF a = Arc
      { start :: a
      , stop :: a
      } deriving (Eq, Ord, Functor, Show, Generic)

    type Arc = ArcF Time

The reason it's called an arc is that a cycle is imagined to lie on a circle.  An arc is a portion of that circle.

So we can create an arc of time:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
arcoftime = Arc 0.5 1.2
arcoftime
~~~

And then query our pattern:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
a = s $ parseBP_E "m n o"
arcoftime = Arc 0.5 1.2
import qualified Data.Map.Strict as Map
query a (State arcoftime Map.empty)
~~~

A smaller window that overlaps only the first event:

~~~{.ghcisession}
import Sound.Tidal.Context
import qualified Data.Map.Strict as Map
a = s $ parseBP_E "m n o"
--cut>>
query a (State (Arc 0 1/6) Map.empty)
:t query a (State (Arc 0 1/6) Map.empty)
~~~

So we're getting a list of events from the query.  Each event contains a `ValueMap`.

## Event type

If we just take the first event:

~~~{.ghcisession}
import Sound.Tidal.Context
import qualified Data.Map.Strict as Map
a = s $ parseBP_E "m n o"
--cut>>
head $ query a $ State (Arc 0 1/6) Map.empty
~~~

Let's pull the event apart.  The event has this type (see `Sound/Tidal/Pattern.hs`):

    -- | An event is a value that's active during a timespan. If a whole
    -- is present, the part should be equal to or fit inside it.
    data EventF a b = Event
      { context :: Context
      , whole :: Maybe a
      , part :: a
      , value :: b
      } deriving (Eq, Ord, Functor, Generic)

    type Event a = EventF (ArcF Time) a

so

~~~{.ghcisession}
import Sound.Tidal.Context
import qualified Data.Map.Strict as Map
a = s $ parseBP_E "m n o"
--cut>>
firstevent = head $ query a $ State (Arc 0 1/6) Map.empty
value firstevent
whole firstevent
part firstevent
context firstevent
~~~

The value is from the string we passed into the initial string expression (`s $ parseBP_E "m n o"`)

The whole is the entire span of the event that our little window overlaps.
(The whole event goes from 0 to one third, our window goes from zero to one
sixth.)

The context is apparently the position within the sourcecode, I guess used when
interpreting expressions in a live coding context.

So if we overlap the first two events and get the second event:

~~~{.ghcisession}
import Sound.Tidal.Context
import qualified Data.Map.Strict as Map
a = s $ parseBP_E "m n o"
--cut>>
firstevent:secondevent:others = query a $ State (Arc (1/6) (3/6)) Map.empty
firstevent
whole firstevent
part firstevent
secondevent
whole secondevent
part secondevent
~~~

So it looks like the way to interpret (⅓>½)-⅔ is

 - (⅓>½) is the part, where the query window overlaps with the event window
 - ⅓ to ⅔ is the whole event window
 - and (⅓>½)-⅔ is a representation that combines both the partial window from the query and the whole event window

And then s: "n" is the key-value pair from the `ValueMap`.

There are some functions to query the window start / ends:

~~~{.ghcisession}
import Sound.Tidal.Context
import qualified Data.Map.Strict as Map
a = s $ parseBP_E "m n o"
firstevent:secondevent:others = query a $ State (Arc (1/6) (3/6)) Map.empty
--cut>>
wholeStart firstevent
wholeStop firstevent
eventPartStart firstevent
eventPartStop firstevent
eventValue firstevent
~~~

I'm not sure if these functions are typically used.  They're probably internal.


## You don't need the s function to examine the internals

You can omit the s function, which is an alias for sound (see `Params.hs`).
But is seems to only accept certain letters then:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
parseBP_E "t r s"
~~~

I guess `s` somehow makes the string mini-language accept more tokens.  But anyway, this works:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
parseBP_E "a e g"
~~~

## Defining and showing patterns

You can use the output as above, or `drawLine`:

~~~{.ghcisession #basicpattern tidalexpression='"a b c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}}
drawLine $ parseBP_E {{tidalexpression}}
~~~

See <https://tidalcycles.org/docs/patternlib/tutorials/mini_notation> for notes
on the syntax of the following examples.

--------------------------------------------------

Tilde is a rest:

~~~{.ghcisession #tildeisarest .spatternexample tidalexpression='parseBP_E "b ~ b ~"' .diagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

So the dot in the `drawLine` output is the rest.

![](tildeisarest.svg)

--------------------------------------------------

Underscore elongates a note:

~~~{.ghcisession #underscoreelongates .spatternexample tidalexpression='parseBP_E "a _ c"' .diagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

The hyphen means that the a note is held for an extra division.

![](underscoreelongates.svg)

--------------------------------------------------

`@` elongates a pattern by some number of counts:

~~~{.ghcisession #atelongates .spatternexample tidalexpression='parseBP_E "a@3 b"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

Repeat an event with * . Notice how it takes the time the event would have taken and subdivides that:

~~~{.ghcisession #repeateventasterisk .spatternexample tidalexpression='parseBP_E "a*2 c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

So instead of getting the cycle divided into three, it's divided into four.

The 'a' events have duration 1/4.

--------------------------------------------------

Use ! to repeat an event.  Contrast this with * .

~~~{.ghcisession #repeateventbang .spatternexample tidalexpression='parseBP_E "a!2 c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

The 'a' events have duration 1/3 here.

--------------------------------------------------

Use square brackets for grouping.

~~~{.ghcisession #squarebrackets .spatternexample tidalexpression='parseBP_E "[a b c] [d e]"' .diagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

So it divided the pattern into two halves, and then divided the first half into
three and the second half into two.

![](squarebrackets.svg)

--------------------------------------------------

You can do the same with a dot:

~~~{.ghcisession #thedot .spatternexample tidalexpression='parseBP_E "a b c . d e"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

So this is where I think it starts to get interesting.
Use a comma to play two patterns in parallel.  Apparently you need the square brackets as well.

~~~{.ghcisession #commaforparallel .spatternexample tidalexpression='parseBP_E "[a b c , d e]"' .diagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

I'm officially feeling this.

The first expression's output orders the interleaved events by onset time.

![](commaforparallel.svg)

--------------------------------------------------

You can create polymetric sequences with braces:

~~~{.ghcisession #polymetricbraces .spatternexample tidalexpression='parseBP_E "{a b c , d e}"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

So it looks like it takes the first pattern and divides the cycle by the number
of elements it has, and then uses that length for each element of the second
pattern.

Contrast with doing it in the other order:

~~~{.ghcisession #polymetricbracesotherorder .spatternexample tidalexpression='parseBP_E "{d e , a b c}"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

So in this second version, the 'a b c' events have a longer duration:
putting the "d e" first divides the cycle in two, and so the "a b c" pattern
repeats every 1.5 cycles.

The vertical bar in the text output seems to show a one-cycle duration.

--------------------------------------------------

You can set the length of the polymetric sequence with `%`.

This expression divides the cycle into eight

~~~{.ghcisession #polymetricdividebyeight .spatternexample tidalexpression='parseBP_E "{a b c d e}%8"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

This expression divides the cycle into seven.

~~~{.ghcisession #polymetricdividebyseven .spatternexample tidalexpression='parseBP_E "{a b c d e}%7"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

Use angle brackets to alternate between the events

~~~{.ghcisession #anglebrackets .spatternexample tidalexpression='parseBP_E "<a b c> d <e f>"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

Use brackets to create a Euclidean rhythm:

~~~{.ghcisession #euclideanrhythm .spatternexample tidalexpression='parseBP_E "a(3,7)"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

## Standard library functions

What we've seen above is the pattern "mini-language".  There are also a lot of pattern functions in the standard libarary.

There is documentation online starting at <https://tidalcycles.org/docs/patternlib/tour/concatenation>.  (See "Small Reference" at the left.)

I'll start to play with some of the basic ones here to understand what they're doing.

--------------------------------------------------

`slow` elongates (i.e., slows down) a pattern

~~~{.ghcisession #slowfunction .spatternexample tidalexpression='slow 2 $ parseBP_E "a a b c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

### Digression: querying across cycle boundaries

Interestingly, `slow` seems to query results on cycle boundaries:

~~~{.ghcisession #slowoneandahalf .spatternexample tidalexpression='slow 1.5 $ parseBP_E "a a b c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

(I'm using `queryArc` and `part` to make the diagrams, so it shows up there as well.)

Using `queryArc` to ask for the events:

~~~{.ghcisession #slowoneandahalfoneeighthticks tidalexpression='s $ slow 1.5 $ parseBP_E "a a b c"' .diagram}
import Sound.Tidal.Context
--cut>>
queryArc ({{tidalexpression}}) (Arc 0 3)
~~~

Pulling this apart (manually) and sorting (manually) we get

    (0>⅜)|s: "a"
    (⅜>¾)|s: "a"
    (¾>1)-1⅛|s: "b"
    ¾-(1>1⅛)|s: "b"
    (1⅛>1½)|s: "c"
    (1½>1⅞)|s: "a"
    (1⅞>2)-2¼|s: "a"
    1⅞-(2>2¼)|s: "a"
    (2¼>2⅝)|s: "b"
    (2⅝>3)|s: "c"

![](slowoneandahalfoneeighthticks.svg)

So it looks like the query is giving back two parts for the first "b" event since it crosses a cycle boundary

 - (¾>1)-1⅛|s: "b"
 - ¾-(1>1⅛)|s: "b"

but note that for both `Event`s the `whole` is the same: (¾>1⅛).  (*This* is
why I take the time to understand how to read the output of these functions...)
I think it'll still only play the one note even though the result of `queryArc`
seems 'wrong' here.

So query windows seem to be split at cycle boundaries.
I'm going to chalk this up to an implementation detail and not worry about it
too much right now.  (That'll teach me - use round numbers!)

I just found `showAll`, which gives the same info

~~~{.ghcisession tidalexpression='s $ slow 1.5 $ parseBP_E "a a b c"'}
import Sound.Tidal.Context
--cut>>
import Sound.Tidal.Show
putStrLn $ showAll (Arc 0 3) $ {{tidalexpression}}
~~~

Meh, I should just drop it.

(Actually, I confirmed using using a tidal repl (BootTidal.hs) and `oscdump`
that using `speed 1.5` sends the OSC messages that you'd expect.  So the
scheduler is doing the right thing when it's sending the messages out even
thought they look surprising in the event list.)

### Back to our regularly scheduled program

`fast` speeds things up

~~~{.ghcisession #fastfunction .spatternexample tidalexpression='fast 3 $ parseBP_E "a b c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

`fastGap` speeds things up but aligns to the cycle

~~~{.ghcisession #fastgapfunction .spatternexample tidalexpression='fastGap 3 $ parseBP_E "a b c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

`compress` squeezes a pattern into a given arc of time

~~~{.ghcisession #compressfunction .spatternexample tidalexpression='compress (1/4,1/2) $ parseBP_E "a b c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

`zoom` zooms in on a portion of a pattern.  It maps the zoomed portion to the
duration of the input pattern.

~~~{.ghcisession #zoomfunction .spatternexample tidalexpression='zoom (1/4,3/4) $ parseBP_E "a b c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

(I don't know why the "b" event isn't shown in the `drawLine` output above.)


--------------------------------------------------

`rev` reverses each cycle of a pattern

~~~{.ghcisession .spatternexample tidalexpression='rev $ slow 2 $ parseBP_E "a ~ b ~ ~ c"'}
import Sound.Tidal.Context
--cut>>
s $ {{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

Input (`slow 2 $ parseBP_E "a ~ b ~ ~ c"`):

~~~{#revfunctioninput tidalexpression='s $ slow 2 $ parseBP_E "a ~ b ~ ~ c"' .diagram .insertdiagram}
~~~

Output (`rev $ slow 2 $ parseBP_E "a ~ b ~ ~ c"`):

~~~{#revfunctionoutput tidalexpression='s $ rev $ slow 2 $ parseBP_E "a ~ b ~ ~ c"' .diagram .insertdiagram}
~~~




## Pattern types

`Pattern` has a type parameter that specifies the kind of data contained in
each event:

    Prelude Sound.Tidal.Context> :k Pattern
    Pattern :: * -> *

    -- | A datatype representing events taking place over time
    data Pattern a = Pattern {query :: State -> [Event a]}

The basic `parseBP_E` function goes from a string to a pattern without a
concrete type variable:

~~~{.ghcisession tidalexpression='parseBP_E "a b c d"'}
import Sound.Tidal.Context
--cut>>
:t parseBP_E
{{tidalexpression}}
:t {{tidalexpression}}
~~~



You can define a pattern containing events which contain various basic types by
giving the expression the concrete type:

~~~{.ghcisession tidalexpression='parseBP_E "1 2 3"'}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}} :: Pattern Double
:t {{tidalexpression}} :: Pattern Double
{{tidalexpression}} :: Pattern Char
:t {{tidalexpression}} :: Pattern Char
{{tidalexpression}} :: Pattern Int
:t {{tidalexpression}} :: Pattern Int
~~~

## Pattern algebra

There's an "algebra" of patterns where you can combine them with various
operations, and it'll combine the individual events in some appropriate and
natural way.

The `(|+)` operator is addition, taking structure from the left (`src/Sound/Tidal/Core.hs`).

~~~{.ghcisession .patternalgebraexample #leftPlusExample1 tidalexpression='parseBP_E "1 2 3" |+ parseBP_E "20 40" :: Pattern Double'  .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

(In the text output, notice that the "22" and the "42" entries correspond to
the same whole event.  I'm taking this to mean that the value changes midway
though the event, but the onset still happens at the "22" in this case.  [I
later confirmed with `oscdump` and a live tidal repl that that's what's
happening -- the value that is lined up when the onset happens is the one that
gets sent.  The change midway through the event does nothing.])

~~~{.ghcisession .patternalgebraexample #leftPlusExample2 tidalexpression='parseBP_E "1 2 3" |+ parseBP_E "20 40 60" :: Pattern Double' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

~~~{.ghcisession .patternalgebraexample #leftPlusExample3 tidalexpression='parseBP_E "1 2 3" |+ parseBP_E "20 40 60 80" :: Pattern Double' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

--------------------------------------------------

The `+|` operator does addition, but takes the events from the right argument:

~~~{.patternalgebraexample #rightPlusExample1 tidalexpression='parseBP_E "1 2 3" +| parseBP_E "20 40" :: Pattern Double' .diagram .insertdiagram}
~~~

~~~{.patternalgebraexample #rightPlusExample2 tidalexpression='parseBP_E "1 2 3" +| parseBP_E "20 40 60" :: Pattern Double' .diagram .insertdiagram}
~~~

~~~{.patternalgebraexample #rightPlusExample3 tidalexpression='parseBP_E "1 2 3" +| parseBP_E "20 40 60 80" :: Pattern Double' .diagram .insertdiagram}
~~~

--------------------------------------------------

The `|+|` operator does addition, but takes the events from both arguments:

~~~{.patternalgebraexample #bothPlusExample1 tidalexpression='parseBP_E "1 2 3" |+| parseBP_E "20 40" :: Pattern Double' .diagram .insertdiagram}
~~~

~~~{.patternalgebraexample #bothPlusExample2 tidalexpression='parseBP_E "1 2 3" |+| parseBP_E "20 40 60" :: Pattern Double' .diagram .insertdiagram}
~~~

~~~{.patternalgebraexample #bothPlusExample3 tidalexpression='parseBP_E "1 2 3" |+| parseBP_E "20 40 60 80" :: Pattern Double' .diagram .insertdiagram}
~~~

--------------------------------------------------

If you use `+`, it's like `|+|`:

~~~{.patternalgebraexample #justPlusExample1 tidalexpression='parseBP_E "1 2 3" + parseBP_E "20 40 60 80" :: Pattern Double' .diagram .insertdiagram}
~~~

--------------------------------------------------

There are a bunch of operators that work in the same way documented
at <https://tidalcycles.org/docs/patternlib/tutorials/pattern_structure>.


## Layering parameter patterns to build up an event stream

So one reason this is interesting is that you can create individual patterns
for several parameters and then combine them into one stream of events.

    tidal> putStrLn $ showAll (Arc 0 3) ((s $ "bd sd hh") |+ (pan $ slow 3 $ "0.2 0.5 0.7"))
    [...](0>⅓)|pan: 0.2f, s: "bd"
    [...](⅓>⅔)|pan: 0.2f, s: "sd"
    [...](⅔>1)|pan: 0.2f, s: "hh"
    [...](1>1⅓)|pan: 0.5f, s: "bd"
    [...](1⅓>1⅔)|pan: 0.5f, s: "sd"
    [...](1⅔>2)|pan: 0.5f, s: "hh"
    [...](2>2⅓)|pan: 0.7f, s: "bd"
    [...](2⅓>2⅔)|pan: 0.7f, s: "sd"
    [...](2⅔>3)|pan: 0.7f, s: "hh"

(I manually edited out the context in the square brackets for legibility.  The
`tidal` prompt comes from running `ghci` with `BootTidal.hs`---see below.)

~~~{.patternalgebraexample #valueAlgebraMapDiagram tidalexpression='(s $ parseBP_E "bd sd hh") |+ (pan $ slow 3 $ parseBP_E "0.2 0.5 0.7") :: Pattern ValueMap' .diagram .insertdiagram}
~~~

## More pattern types

The `s` that we have been using is an alias for `sound`, which I guess selects
a sound sample from the set of named samples.  It's defined in
`src/Sound/Tidal/Params.hs`.

    sound :: Pattern String -> ControlPattern
    sound = grp [mS "s", mF "n"]

    s :: Pattern String -> ControlPattern
    s = sound

A `ControlPattern` is a pattern that contains events with a map of values in
them.  It is defined in `src/Sound/Tidal/Pattern.hs`

    type ControlPattern = Pattern ValueMap

    type ValueMap = Map.Map String Value

So `sound` contains a string "s" parameter and a float "n" parameter.
I believe it's the sound name and the note/sample number.
(So for e.g. bass drum samples, there are several bass drums to choose from.)

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
:t sound
:t s
:t sound . parseBP_E
sound $ parseBP_E "a b c d"
:t sound $ parseBP_E "a b c d"
~~~

There's also `n` (`src/Sound/Tidal/Params.hs`):

    -- | The note or sample number to choose for a synth or sampleset
    n :: Pattern Note -> ControlPattern
    n = pN "n"

(I started to chase these functions around but it got kind of hairy for my
level of understanding.  I'll have to live with trying to understand things
from the code comments.)

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
:t n . parseBP_E
n $ parseBP_E "1 2 3 4"
:t n $ parseBP_E "1 2 3 4"
~~~

(I think `unNote` is the field name that you would call to extract the float
value from a note.)

So I think what you can do is combine `sound` and `n` patterns into one
`ControlPattern`.  So starting with these expressions:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
s $ parseBP_E "a b c d"
:t s $ parseBP_E "a b c d"
n $ parseBP_E "1 2 3 4"
:t n $ parseBP_E "1 2 3 4"
~~~

here are two ways to do the set the sample number for each event:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
s $ parseBP_E "a:1 b:2 c:3 d:4"
:t s $ parseBP_E "a:1 b:2 c:3 d:4"
(s $ parseBP_E "a b c d") |> (n $ parseBP_E "1 2 3 4")
:t (s $ parseBP_E "a b c d") |> (n $ parseBP_E "1 2 3 4")
~~~

It seems to me that these are equivalent since `type ControlPattern = Pattern ValueMap`.
I verified that they are equivalent looking at the OSC messages that get sent
out---they're the same in both cases.

    /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 13.000000 "delta" 0.444444 "n" 1.000000 "orbit" 0 "s" "a"
    /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 13.250000 "delta" 0.444445 "n" 2.000000 "orbit" 0 "s" "b"
    /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 13.500000 "delta" 0.444445 "n" 3.000000 "orbit" 0 "s" "c"
    /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 13.750000 "delta" 0.444444 "n" 4.000000 "orbit" 0 "s" "d"

## Booting Tidal from ghci

You can actually boot a live tidal from ghci and get a prompt:

    $ ghci
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    Prelude> :script BootTidal.hs
    [TidalCycles version 1.7.8]
    Installed in /.../.cabal/store/ghc-8.10.7/tdl-1.7.8-5d5b197d/share
    Listening for external controls on 127.0.0.1:6010
    tidal> Waiting for SuperDirt (v.1.7.2 or higher)..

    tidal>
    tidal> s "a b c"
    (0>⅓)|s: "a"
    (⅓>⅔)|s: "b"
    (⅔>1)|s: "c"

Either run `ghci` and then `:script BootTidal.hs`, or run
`ghci -ghci-script BootTidal.hs`.


## Inspecting OSC

You can use `oscdump` from `liblo` to see what messages are coming in:

    $ ./oscdump 57120

Then in the tidal repl:

    $ ghci -ghci-script BootTidal.hs
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    [TidalCycles version 1.7.8]
    Installed in /.../.cabal/store/ghc-8.10.7/tdl-1.7.8-5d5b197d/share
    Listening for external controls on 127.0.0.1:6010
    Loaded GHCi configuration from BootTidal.hs
    tidal> Waiting for SuperDirt (v.1.7.2 or higher)..

    tidal>
    tidal> d1 $ s "bd"

You see in the running `oscdump`:

    e520f7d6.950bd000 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 47.000000 "delta" 1.777778 "orbit" 0 "s" "bd"
    e520f7d6.faaf9a8b /dirt/handshake
    e520f7d8.5c284800 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 48.000000 "delta" 1.777778 "orbit" 0 "s" "bd"
    e520f7d8.fae3e6c3 /dirt/handshake


Another example:

    tidal> d1 $ s "bd" + (n "1 2 3")

    in oscdump:
    e520f856.950bd000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 119.000000 "delta" 0.592593 "n" 1.000000 "orbit" 0 "s" "bd"
    e520f857.26c8a372 /dirt/handshake
    e520f857.2cbff800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 119.333336 "delta" 0.592593 "n" 2.000000 "orbit" 0 "s" "bd"
    e520f857.c4742000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 119.666664 "delta" 0.592593 "n" 3.000000 "orbit" 0 "s" "bd"
    e520f858.5c284800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 120.000000 "delta" 0.592592 "n" 1.000000 "orbit" 0 "s" "bd"
    e520f858.f3dc6800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 120.333336 "delta" 0.592593 "n" 2.000000 "orbit" 0 "s" "bd"
    e520f859.2854de7e /dirt/handshake
    e520f859.8b909000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 120.666664 "delta" 0.592593 "n" 3.000000 "orbit" 0 "s" "bd"

So this would be a good way to understand how patterns are played and what's
the result of combining patterns.

Use this to prevent the handshake messages from showing up:

    ./oscdump -L 57120 | grep -v dirt.handshake

## Continuous patterns

Tidal also has continuous patterns, like `sine`:


~~~{.tidalsession}
putStrLn $ showAll (Arc 0 0) $ pan sine
putStrLn $ showAll (Arc 0.1 0.1) $ pan sine
putStrLn $ showAll (Arc 0.2 0.2) $ pan sine
putStrLn $ showAll (Arc 0.25 0.25) $ pan sine
putStrLn $ showAll (Arc 0.5 0.5) $ pan sine
putStrLn $ showAll (Arc 0.75 0.75) $ pan sine
putStrLn $ showAll (Arc 1.0 1.0) $ pan sine
putStrLn $ showAll (Arc 1.25 1.25) $ pan sine
putStrLn $ showAll (Arc 1.5 1.5) $ pan sine
putStrLn $ showAll (Arc 1.75 1.75) $ pan sine
~~~

So it varies continuously.

`sine` is defined in `src/Sound/Tidal/Core.hs`

These continuous patterns are implemented via `sig` in `Core.hs`

    -- | Takes a function from time to values, and turns it into a 'Pattern'.
    sig :: (Time -> a) -> Pattern a

When you query over an arc, it apparently gives back the whole arc as the
event extents.

~~~{.tidalsession}
queryArc (pan sine) (Arc 0.5 2)
~~~

NB: `sig` evaluates the continuous function in the *middle* of the query arc!

~~~{.tidalsession #sigEvaluatesAtMiddle .signalsamplingexample tidalexpression='queryArc (pan sine) (Arc 0.5 0.7)' .diagram .insertdiagram}
{{tidalexpression}}
queryArc (pan sine) (Arc 0.6 0.6)
~~~

### Setting event parameters from a continuous pattern

I want to try taking the panning value for each event of a pattern from a
second continuous signal.

This doesn't do what you (I) might expect, given pattern algebra:

~~~{.tidalsession}
(s $ "a b c d") + (pan $ sine)
~~~

since

~~~{.tidalsession}
pure sine
pan $ sine
~~~

(I thought it might be misguided to try to do this with pattern algebra in the
first place since pattern algebra seems to assume discrete patterns, but it
seems that this is one way to get values out of continuous patterns.)

You need to use the `segment` function to first sample the continuous pattern
before applying it to the notes:

~~~{.tidalsession #sigToSetPanning .signalsetsparameter tidalexpression='(pan $ segment 7 $ sine) +| (s $ "a b c d")' .diagram .insertdiagram}
{{tidalexpression}}
filterEvents eventHasOnset $ {{tidalexpression}}
~~~

I confirmed with `oscdump` that this is effectively only applying the panning
value at each note onset.  The events without onsets don't get sent out over
OSC.

So you need to turn the continuous ("analog") signal into a discrete
("digital") one before you can use `+|`.  Also note that here I used the plus
that takes the events from the right argument so that I get notes out, and not
one note per segment of the sampled sine wave.

See <http://tidalcycles.org/docs/reference/sampling/#segment> for an example of
`segment` which is close to this.

(I looked into the code for `segment` but it was kind of hard to understand at
this point.  It calls into `tParam`, which is a general internal helper
function; `tParam` creates a pattern of patterns and then flattens
(`innerJoin`s) it.)

