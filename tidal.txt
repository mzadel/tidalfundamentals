---
title: 'Learning Tidal Fundamentals'
author: 'Mark Zadel'
date: 'December 2021'

fontsize: 12pt
monobackgroundcolor: 'LightGrey'
header-includes: |
  <style>
  body {
    max-width: 60em;
  }
  img {
    max-width: none;
  }
  </style>
---

## Introduction

These are the notes I made when trying to first understand how [Tidal
Cycles](https://tidalcycles.org/) works.

This isn't about making sound!  It's about trying to fundamentally understand
the expressions and values to have a good basis going forward, and about
getting started writing your own Tidal libraries.  If you're a musician and you
just want to make music with Tidal, you don't need this information.

This document ended up being more elaborate than I'd originally intended.  It
gives an overview of Tidal's types and core APIs, shows how to run it as a
library from ghci, and explores some of its concepts.  I think the main
contributions here are a relatively thorough survey of the core code, the
working code examples to try and to modify, and the diagrams.  Hopefully it
will be helpful for developers trying to understand Tidal.


## Installing the Tidal library in Haskell

MacOS | Tidal Cycles<br/>
<https://tidalcycles.org/docs/getting-started/macos_install>

### Install via cabal

I tried installing a few different times in a few different ways, and
the method I preferred was the following:

 - Use `ghcup` (<https://www.haskell.org/ghcup/>)
     - Install `ghc` with `ghcup`
     - Add `$HOME/.ghcup/bin:$HOME/.ghcup/ghc/8.10.7/bin` to `$PATH` in `.bashrc`
     - Install `cabal` with `ghcup`
     - `cabal update`
     - `cabal install tidal --lib`

NB: THIS IS NOT SUFFICIENT TO MAKE SOUND!!  I'm only interested in
executing expressions and inspecting types at this stage.  Look at
the installation instructions on
[tidalcycles.org](https://tidalcycles.org) for installing
SuperCollider, SuperDirt and a compatible text editor, which are all
required for a typical install.

I initially had linker errors when compiling Haskell code.  What I
had to do was uninstall ghc and cabal, uninstall all of my homebrew
programs, reinstall ghc and cabal, and then it worked.  (It was fine
to reinstall homebrew for me since there was a lot of cruft left
around that I'd just kept upgrading over several years and OS
versions.)

The `--lib` part is important.  That makes it possible to run `import
Sound.Tidal.Context` in `ghci`.

You can delete `.ghc`, `.ghcup` and `.cabal` to start over from
scratch if you're trying to debug install problems.

### Alternative: install via stack

You can also use stack:

 - Run `stack setup`
     - This will download the latest LTS version of GHC
     - The LTS resolver version can be checked in `~/.stack/global-project/stack.yaml`: `resolver: lts-18.13`
     - Go to <https://www.stackage.org> and click on LTS at the top to check the most recent stable version
     - It ends up in `~/.stack/programs/x86_64-osx/ghc-8.10.7/bin/ghc`
         - See `stack path`
     - Invoke as `stack ghc` or `stack ghci`
 - `stack install --no-library-stripping tidal`

You can blow away `~/.stack` to reset your install for
fixing installation problems.

`--no-library-stripping` is important, since it's needed to import
Tidal inside a `ghci` session.

### Installing diagrams (optional, not needed for Tidal)

I also installed `diagrams` for making the diagrams.  (You don't need
to do this.)

 - With cabal
     - `cabal install diagrams-core --lib`
     - `cabal install diagrams-lib --lib`
     - `cabal install diagrams-svg --lib`
     - `cabal install palette --lib`
 - With stack
     - change your stack install to a nightly instead of LTS.  The
       LTS one doesn't include diagrams for some reason.
     - `stack install --no-library-stripping diagrams-core`
     - `stack install --no-library-stripping diagrams-lib`
     - `stack install --no-library-stripping diagrams-svg`
     - `stack install --no-library-stripping palette`

I couldn't install the top-level `diagrams` library since I don't
think it worked with the `--lib` flag.  (I would have to confirm that
detail, though.)




## Sanity checking the basic Tidal install

    $ ghci
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    Prelude> import Sound.Tidal.Context
    Prelude Sound.Tidal.Context> tidal_version
    "1.7.8"


## Starting to look at some expressions

This seems to work in the online examples but not in ghci:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
s $ "bd bd bd"
~~~

It needs `parseBP_E`, which is automatically, silently added when running from the text editor.  In a normal `ghci`:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
s $ parseBP_E "bd bd bd"
~~~

You can turn on the implicit string handling with `{-# language OverloadedStrings #-}`, or the equivalent `:set -XOverloadedStrings` in `ghci` (see Waldmann article below).

~~~{.ghcisession}
import Sound.Tidal.Context
:set -XOverloadedStrings
s $ "bd bd bd"
~~~

`OverloadedStrings` is described at <https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/overloaded_strings.html> .
I'd prefer not to use it right now since I'm explicitly trying to figure out the types and to understand the core definitions.



## `Core.hs`

The basic functions for making patterns are in `Pattern.hs`, `Core.hs` and
`UI.hs` (as far as I can tell).

Almost all the examples you see start from Tidal's pattern mini-language (like
`s $ "a b c"`), but that's not necessary for making patterns and it's outside
the core functionality.  I'm going to start by surveying some of the basic API
in `Core.hs`.

There is API documentation online starting at
<https://tidalcycles.org/docs/patternlib/tour/concatenation>.  (See "Small
Reference" at the left.)

A pattern is something you can query to get a list of events.  Events have
extents in time and can carry an arbitrary kind of data.  From `Pattern.hs`:

    data Pattern a = Pattern {query :: State -> [Event a]}

    type Event a = EventF (ArcF Time) a


The most basic pattern is made via `pure`:

~~~{.ghcisession #purecycle tidalexpression='pure "eventcontents" :: Pattern String' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

So this is a pattern that has one event per cycle, and the event's contents are
the string `"eventcontents"`.

A cycle is some amount of time, like a bar, or say four bars of music.  You can
set it to whatever you want, but it's the basic sync period for a loop.

--------------------------------------------------

You can make an empty pattern with `silence` (`Core.hs`), which is just an
alias for `empty` (`Pattern.hs`).

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
silence
:t silence
~~~

(There are no events to print.)

--------------------------------------------------

You can use `fromList` (`Core.hs`) to make a pattern where each list item
corresponds to an event with length one cycle:

~~~{.ghcisession #fromListExample tidalexpression='fromList ["phi", "psi" , "tau"]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
pat = {{tidalexpression}}
pat
putStrLn $ showAll (Arc 0 3) pat
:t pat
~~~

`showAll` from `Show.hs` takes an `Arc` argument, so we can print the pattern
over more than one cycle.

--------------------------------------------------

Use `fastFromList` (`Core.hs`) to make a pattern that squeezes each list item
into one cycle:

~~~{.ghcisession #fastFromListExample tidalexpression='fastFromList ["phi", "psi" , "tau"]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
pat = {{tidalexpression}}
pat
:t pat
~~~

We can also draw the pattern on a circle to reflect its cyclical nature:

~~~{#fastFromListExampleCircular tidalexpression='fastFromList ["phi", "psi" , "tau"]' .diagram .insertdiagram}
~~~

`listToPat` is a synonym from `fastFromList`.

--------------------------------------------------

`fromMaybes` allows you to put gaps in the pattern:

~~~{.ghcisession #fromMaybesExample tidalexpression='fromMaybes [Just "phi", Nothing, Just "tau"]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
pat = {{tidalexpression}}
pat
:t pat
~~~

--------------------------------------------------

`append` alternates between cycles of two patterns.

~~~{.ghcisession #appendExample tidalexpression='append (fromList [\'a\', \'j\']) (fromList [\'c\', \'k\'])' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
pat = {{tidalexpression}}
putStrLn $ showAll (Arc 0 8) pat
:t pat
~~~

--------------------------------------------------

`cat` alternates between cycles of several patterns.

~~~{.ghcisession #catExample tidalexpression='cat [fromList [\'a\', \'j\'], fromList [\'c\', \'k\'], fromList [\'e\', \'l\']]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
pat = {{tidalexpression}}
putStrLn $ showAll (Arc 0 8) pat
:t pat
~~~

`slowCat` and `slowcat` (lowercase) are aliases for `cat`.

--------------------------------------------------

`fastCat` (also `fastcat`), works like `cat` but squeezes all the patterns into one cycle

~~~{.ghcisession #fastCatExample tidalexpression='fastCat [fromList [\'a\', \'j\'], fromList [\'c\', \'k\'], fromList [\'e\', \'l\']]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
pat = {{tidalexpression}}
putStrLn $ showAll (Arc 0 3) pat
:t pat
~~~

--------------------------------------------------

`timeCat` takes patterns and squeezes them into parts of a cycle.  The time
argument for each pattern is its relative duration.

~~~{.ghcisession #timeCatExample tidalexpression='timeCat [(1, fastFromList [\'a\', \'b\']), (2, fastFromList [\'c\', \'d\', \'e\'])]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

You could imagine using this for creating events of arbitrary lengths.

--------------------------------------------------

`overlay` superimposes two patterns, playing them in parallel.

~~~{.ghcisession #overlayExample tidalexpression='overlay (fastFromList [\'a\', \'b\', \'c\', \'d\']) (fastFromList [\'j\', \'k\', \'l\'])' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

--------------------------------------------------

`stack` superimposes a list of patterns.

~~~{.ghcisession #stackExample tidalexpression='stack [pure \'a\', fastFromList [\'j\', \'k\', \'l\'], fromList [\'m\', \'n\']]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

--------------------------------------------------

`fast` speeds things up

~~~{.ghcisession #fastfunction tidalexpression='fast 3 $ fastFromList [\'a\', \'b\', \'c\']' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

`drawLine` is a utility function from `Show.hs` that renders out a `Pattern
Char` as ascii art.  It only works on char patterns!

--------------------------------------------------

`slow` elongates (i.e., slows down) a pattern

~~~{.ghcisession #slowfunction tidalexpression='slow 2 $ fastFromList [\'a\', \'a\', \'b\', \'c\']' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

`fastGap` speeds things up but aligns to the cycle

~~~{.ghcisession #fastgapfunction tidalexpression='fastGap 3 $ fastFromList [\'a\', \'b\', \'c\']' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

`compress` squeezes a pattern into a given arc of time

~~~{.ghcisession #compressfunction tidalexpression='compress (1/4,1/2) $ fastFromList [\'a\', \'b\', \'c\']' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

--------------------------------------------------

`zoom` zooms in on a portion of a pattern.  It maps the zoomed portion to the
duration of the input pattern.

~~~{.ghcisession #zoomfunction tidalexpression='zoom (1/4,3/4) $ fastFromList [\'a\', \'b\', \'c\']' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

(I don't know why the "b" event isn't shown in the `drawLine` output above.)


--------------------------------------------------

`rev` reverses each cycle of a pattern

~~~{.ghcisession tidalexpression='rev $ slow 2 $ fromMaybes [Just \'a\', Nothing, Just \'b\', Nothing, Nothing, Just \'c\']'}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

Input (`slow 2 $ fromMaybes [Just 'a', Nothing, Just 'b', Nothing, Nothing, Just 'c']`):

~~~{#revfunctioninput tidalexpression='slow 2 $ fromMaybes [Just \'a\', Nothing, Just \'b\', Nothing, Nothing, Just \'c\']' .diagram .insertdiagram}
~~~

Output (`rev $ slow 2 $ fromMaybes [Just 'a', Nothing, Just 'b', Nothing, Nothing, Just 'c']`):

~~~{#revfunctionoutput tidalexpression='rev $ slow 2 $ fromMaybes [Just \'a\', Nothing, Just \'b\', Nothing, Nothing, Just \'c\']' .diagram .insertdiagram}
~~~


--------------------------------------------------

`every` applies a function to the input pattern, but only every `n` cycles.

~~~{.ghcisession #everyfunction tidalexpression='every 3 rev $ fastFromList [\'a\', \'b\', \'c\']' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
drawLine $ {{tidalexpression}}
~~~

The '`n` cycles' argument is actually of type `Pattern Int`, so you can vary
the argument over time like this:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
pat = fastFromList ['a', 'b', 'c']
ints = slow 6 $ cat [2, 3]
drawLine $ every ints rev pat
~~~

For the first six cycles the pattern is reversed every two repetitions; for the
second six cycles the pattern is reversed every three.



--------------------------------------------------

`when` applies a function when the given predicate function returns true.
The predicate is fed the current cycle number.

~~~{.ghcisession #whenfunction tidalexpression='when (\x -> (x+2) `mod` 3 == 0) rev (fastFromList [\'a\',\'b\',\'c\'])' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
drawLine $ {{tidalexpression}}
~~~



--------------------------------------------------

`rotR` shifts a pattern forward in time by a certain number of cycles.

~~~{.ghcisession #rotRexample tidalexpression='rotR (1%3) (fastFromList [\'a\', \'b\', \'c\'])' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
drawLine $ {{tidalexpression}}
~~~

You can use `rotR` and `fastGap` to manually put an event at a particular point
in time with a particular duration.

~~~{.ghcisession #rotRwithfastGap tidalexpression='rotR (3%8) (fastGap 4 (pure \'a\'))' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~


## Queries

Patterns can be queried over a time range, returning a list of events.  The
scheduler does this repeatedly over small time slices to decide when to send
OSC ([Open Sound Control](https://en.wikipedia.org/wiki/Open_Sound_Control))
messages to SuperCollider.  We can use this to check how our pattern will be
rendered.

Each `Pattern` implements `query`:

    data Pattern a = Pattern {query :: State -> [Event a]}

    data State = State {arc :: Arc,
                        controls :: ValueMap
                       }

You pass in a `State`, but for our purposes we'll always leave `controls` empty.
(I understand it to be the current values of any external MIDI controllers,
which we don't need.)  That means `query` essentially goes from an `Arc` of
time to a list of `Event`s; that's exactly what `queryArc` does:

    queryArc :: Pattern a -> Arc -> [Event a]
    queryArc p a = query p $ State a Map.empty

The events that are returned have a `whole` and a `part`, which we'll get into
later.

--------------------------------------------------

~~~{.ghcisession #queryFullCycle .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0 1)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

In this example, each of the output events has a `whole`, and that `whole` is the same as its `part`.

--------------------------------------------------

~~~{.ghcisession #queryHalfCycle .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0 0.5)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

--------------------------------------------------

~~~{.ghcisession #queryQuarterCycle .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0 0.25)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

So we see here that the output `Event`'s `whole` is the entire extent of the
input event that intersects with the query `Arc`; the `part` is the
intersection of the query `Arc` and the overlapping input event.

We see `(⅕>¼)-⅖` in the ghci output.  The way to read this is

 - `(⅕>¼)` is the part, where the query window overlaps with the input event window,
 - `⅕` to `⅖` is the whole, and
 - `(⅕>¼)-⅖` is a representation that combines both the part and the whole

--------------------------------------------------

~~~{.ghcisession #queryEmptySpace .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0 0.2)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

Querying an arc that doesn't overlap any pattern events returns an empty list.
Note here that the right edge of the query arc touches the first pattern event.

--------------------------------------------------

~~~{.ghcisession #queryOverlapOneItemExactly .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0.6 0.8)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

--------------------------------------------------

~~~{.ghcisession #queryOverlapOneItemExactly2 .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0.8 1.0)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

--------------------------------------------------

~~~{.ghcisession #queryOverlapTwoItemsExactly .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0.6 1.0)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

--------------------------------------------------

~~~{.ghcisession #queryOverlapTwoItems .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0.7 0.9)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

--------------------------------------------------

~~~{.ghcisession #queryTwoItemsZeroWidth .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0.8 0.8)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

So if you query a zero-width arc right between two events, it returns only the
second event (with a zero-width part).

--------------------------------------------------

~~~{.ghcisession #queryOneItemZeroWidth .queryexample tidalexpression='queryArc (fromMaybes [Nothing,Just \'a\', Nothing, Just \'c\', Just \'d\']) (Arc 0.75 0.75)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

Note here how the event's extents are notated: `⅗-(¾>¾)-⅘`.

### Querying continuous patterns

Tidal also has a concept of a continuous pattern.

~~~{#simplesine tidalexpression='sine :: Pattern Double' .diagram .insertdiagram}
~~~

(This is `sine` from `Core.hs`.)

These patterns accept `query` like any other pattern.

~~~{.ghcisession #querycontinuouspattern .queryexamplecontinuous tidalexpression='queryArc sine (Arc 0.5 0.75)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

Let's look into the details to see what the query is returning and where the
floating point value is coming from.

~~~{.ghcisession #querycontinuouspatternshowpoint .queryexamplecontinuous tidalexpression='queryArc sine (Arc 0.5 0.75)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
results = {{tidalexpression}}
results
:t results
length results
event : _ = results
:t event
whole event
part event
value event
~~~

So we see that querying a continuous pattern returns events with parts and
values, but no wholes.

The notation for continuous results includes tildes: `~½>¾~`.

Note too that the query samples the continuous function in the middle of the
query arc.

~~~{.ghcisession #querycontinuouspatternsamplesatmidpoint .queryexamplecontinuous tidalexpression='queryArc sine (Arc 0.3 0.5)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
queryArc sine (0.4 :: Arc)
~~~

If you want to sample a continuous pattern at exactly one point, use a zero-width arc.

~~~{.ghcisession #querycontinuouspatternzwarc .queryexamplecontinuous tidalexpression='queryArc sine (Arc 0.22 0.22)' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

Tidal calls continuous patterns "analog" and discrete patterns "digital":

    isAnalog :: Event a -> Bool
    isAnalog (Event {whole = Nothing}) = True
    isAnalog _ = False

    isDigital :: Event a -> Bool
    isDigital = not . isAnalog

(from `Pattern.hs`)

## Basic types (`Pattern.hs`)

We've seen several examples of patterns, events and queries.  Hopefully that
will have built up enough intuition to make sense of the basic types.

`Pattern` is defined in `Sound/Tidal/Pattern.hs`.

    -- | A datatype representing events taking place over time
    data Pattern a = Pattern {query :: State -> [Event a]}
      deriving (Generic, Functor)

A pattern is something that can be queried, returning a list of events.

An `Arc` is an interval of time.  Time is expressed as a rational (i.e., a fraction)  (defined in `Sound/Tidal/Time.hs`)

    -- | Time is rational
    type Time = Rational

    -- | An arc of time, with a start time (or onset) and a stop time (or offset)
    data ArcF a = Arc
      { start :: a
      , stop :: a
      } deriving (Eq, Ord, Functor, Show, Generic)

    type Arc = ArcF Time

I think the reason it's called an arc is that a cycle is imagined to lie on a circle.  An arc is a portion of that circle.

`Event`s are defined thusly (see `Sound/Tidal/Pattern.hs`):

    -- | An event is a value that's active during a timespan. If a whole
    -- is present, the part should be equal to or fit inside it.
    data EventF a b = Event
      { context :: Context
      , whole :: Maybe a
      , part :: a
      , value :: b
      } deriving (Eq, Ord, Functor, Generic)

    type Event a = EventF (ArcF Time) a

So events are understood to be boxes on the timeline with a beginning and an
end, which contain a value.  We also have the notion of looking at a subsection
of an event, hence the `whole` and `part` distinction.  `whole` is `Maybe a`,
so it might be `Nothing`, which means that it's from an analog (continuous)
pattern.

`value` is, of course, the value that the event contains.

The context is apparently the position within the source code.  I guess this is
used when interpreting expressions in a live coding context.

There are some utility functions to access an event's fields in `Pattern.hs`:
`isAnalog`, `isDigital`, `wholeStart`, `wholeStop`, `eventPartStart`,
`eventPartStop`, etc.


## Patterns as numbers

You can perform many operations on patterns as though they were numbers:

~~~{.ghcisession #numberpatternmin .intpatternexample tidalexpression='min 27 $ fastFromList [11,22,33,44]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

~~~{.ghcisession #numberpatternmax .intpatternexample tidalexpression='max 27 $ fastFromList [11,22,33,44]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

~~~{.ghcisession #numberpatternplus .intpatternexample tidalexpression='fastFromList [11,22,33,44] + 3' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

~~~{.ghcisession #numberpatterntimes .intpatternexample tidalexpression='2 * fastFromList [11,22,33,44]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

~~~{.ghcisession #numberpatternmod .intpatternexample tidalexpression='mod (fastFromList [11,22,33,44]) 4' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

~~~{.ghcisession #numberpatternsqrt .doublepatternexample tidalexpression='sqrt $ fastFromList [2,9,16,100]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

Neat.

## Pattern Algebra

What happens when we straight up add two patterns together?

~~~{.ghcisession #additionexample .patternalgebraexample tidalexpression='fastFromList [1, 2, 3] + fastFromList [20, 40] :: Pattern Int' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

Tidal adds the patterns together by combining the events and values from both
input patterns.  Internally, Tidal does the addition via `applyPatToPatBoth` in `Pattern.hs`.

There are other addition operators that combine the events in alternate ways
that call `applyPatToPatLeft` and `applyPatToPatRight` instead.

The `(|+)` operator is addition, taking structure (i.e., the wholes) from the left (`src/Sound/Tidal/Core.hs`).

~~~{.ghcisession .patternalgebraexample #leftPlusExample1 tidalexpression='fastFromList [1, 2, 3] |+ fastFromList [20, 40] :: Pattern Int'  .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

(In the text output, notice that the "22" and the "42" entries correspond to
the same whole event.  I understand this to mean that the value changes midway
though the event, but the onset still happens at the "22" in this case.  I
later confirmed with `oscdump` and a live Tidal REPL that that's what's
happening -- the value that is lined up when the onset happens is the one that
gets sent.  The change midway through the event does nothing.)

~~~{.ghcisession .patternalgebraexample #leftPlusExample2 tidalexpression='fastFromList [1, 2, 3] |+ fastFromList [20, 40, 60] :: Pattern Int' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

~~~{.ghcisession .patternalgebraexample #leftPlusExample3 tidalexpression='fastFromList [1, 2, 3] |+ fastFromList [20, 40, 60, 80] :: Pattern Int' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

--------------------------------------------------

The `+|` operator does addition, but takes the events from the right argument:

~~~{.patternalgebraexample #rightPlusExample1 tidalexpression='fastFromList [1, 2, 3] +| fastFromList [20, 40] :: Pattern Int' .diagram .insertdiagram}
~~~

~~~{.patternalgebraexample #rightPlusExample2 tidalexpression='fastFromList [1, 2, 3] +| fastFromList [20, 40, 60] :: Pattern Int' .diagram .insertdiagram}
~~~

~~~{.patternalgebraexample #rightPlusExample3 tidalexpression='fastFromList [1, 2, 3] +| fastFromList [20, 40, 60, 80] :: Pattern Int' .diagram .insertdiagram}
~~~

--------------------------------------------------

The `|+|` operator does addition, but takes the events from both arguments:

~~~{.patternalgebraexample #bothPlusExample1 tidalexpression='fastFromList [1, 2, 3] |+| fastFromList [20, 40] :: Pattern Int' .diagram .insertdiagram}
~~~

~~~{.patternalgebraexample #bothPlusExample2 tidalexpression='fastFromList [1, 2, 3] |+| fastFromList [20, 40, 60] :: Pattern Int' .diagram .insertdiagram}
~~~

~~~{.patternalgebraexample #bothPlusExample3 tidalexpression='fastFromList [1, 2, 3] |+| fastFromList [20, 40, 60, 80] :: Pattern Int' .diagram .insertdiagram}
~~~

--------------------------------------------------

If you use `+`, it's like `|+|`:

~~~{.patternalgebraexample #justPlusExample1 tidalexpression='fastFromList [1, 2, 3] + fastFromList [20, 40, 60, 80] :: Pattern Int' .diagram .insertdiagram}
~~~

--------------------------------------------------

There are a bunch of operators that work in the same way documented
at <https://tidalcycles.org/docs/patternlib/tutorials/pattern_structure>.


## Applying a pattern of functions

The above are examples of `Pattern`'s `Applicative` instance, which is a
Haskell thing.  It allows you to apply a pattern of unary functions to a
pattern of arguments.

    instance Applicative Pattern where
      -- | Repeat the given value once per cycle, forever
      pure v = Pattern $ \(State a _) ->
        map (\a' -> Event (Context []) (Just a') (sect a a') v) $ cycleArcsInArc a

      (<*>) = applyPatToPatBoth


~~~{.ghcisession #applicativeboth .applicativeexample tidalexpression='fastFromList [ (2.0*), exp, (max 7) ] <*> fastFromList [1, 2] :: Pattern Double' .diagram .insertdiagram}
import Prelude hiding ((<*), (*>))
import Sound.Tidal.Context
--cut>>
a = {{left}}
:t a
b = {{right}}
a {{operator}} b
~~~

There are also the operators `<*` and `*>`, which take the structure from the left and right, respectively.

~~~{.ghcisession #applicativeleft .applicativeexample tidalexpression='fastFromList [ (2.0*), exp, (max 7) ] <* fastFromList [1, 2] :: Pattern Double' .diagram .insertdiagram}
--cut>>
import Prelude hiding ((<*), (*>))
import Sound.Tidal.Context
a = {{left}}
b = {{right}}
a {{operator}} b
~~~

~~~{.ghcisession #applicativeright .applicativeexample tidalexpression='fastFromList [ (2.0*), exp, (max 7) ] *> fastFromList [1, 2] :: Pattern Double' .diagram .insertdiagram}
import Prelude hiding ((<*), (*>))
import Sound.Tidal.Context
a = {{left}}
b = {{right}}
--cut>>
a {{operator}} b
~~~

(Only the first event contains the whole's onset, so that's the one that'll get
sent out via OSC.)

These operators are the more general ones that are called into by `|+`, `+|`, etc.


## Mapping over a pattern

You can map a function over a `Pattern`.  It'll apply the function to that
pattern's events.

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
fmap abs fastFromList [ 2, -3, 1, -1, 4 ]
fmap ((+3) . (*2)) fastFromList [ 1, 2, 3, 4 ]
~~~

There are also various filter functions defined in `Pattern.hs`.

~~~{.ghcisession #filtervaluesexample .intpatternexample tidalexpression='filterValues (> 0) $ fastFromList [ 2, -3, 1, -1, 4 ]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

See `filterJust`, `filterWhen`, `filterOnsets`, `filterEvents`, etc.

## The (#) operator

You see the operator `(#)` in Tidal examples a lot, such as `sound "bd*8" # pan
rand`.  It's an alias for `(|>)`, which is one of the pattern union operators.
From `Core.hs`:

    -- Backward compatibility - structure from left, values from right.
    (#) :: Unionable b => Pattern b -> Pattern b -> Pattern b
    (#) = (|>)

    (|> ) :: Unionable a => Pattern a -> Pattern a -> Pattern a
    a |>  b = flip union <$> a <* b

So it takes the events from the left pattern, and does the `ValueMap` union
with the values from the pattern on the right.


## Patterns of patterns

You can of course define patterns of patterns as well.

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
pat = fastFromList [ fastFromList ['a','b','c'], fastFromList ['d','e'] ]
pat
:t pat
~~~

The way to read this is that there's one event on `(0>½)` that contains the first pattern,
and there's a second event on `(½>1)` that contains the second pattern.

--------------------------------------------------

You can use `unwrap` if you want to flatten the patterns:

~~~{.ghcisession #unwrapexample tidalexpression='unwrap $ fastFromList [ fastFromList [\'a\',\'b\',\'c\'], fastFromList [\'j\',\'k\',\'l\',\'m\'] ]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
pat = {{tidalexpression}}
pat
:t pat
~~~

So this is allowing the inner patterns to shine through the windows defined by
the events they're contained in.  The wholes and the parts are cleaned up so
that they're coincident for every event.

--------------------------------------------------

`innerJoin` flattens the pattern but takes the structure from the inner pattern.

~~~{.ghcisession #innerjoinexample tidalexpression='innerJoin $ fastFromList [ fastFromList [\'a\',\'b\',\'c\'], fastFromList [\'j\',\'k\',\'l\',\'m\'] ]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

The events are defined by the inner patterns over the entire cycle, and those
windowed by the outer events they're contained in.  This looks like the
`unwrap` case, but the wholes from the inner pattern are preserved in the
output events.

We can emulate this with `queryArc` to help understand what `innerJoin` is doing:

~~~{.ghcisession #innerjoinasqueryarc}
import Sound.Tidal.Context
--cut>>
queryArc (fastFromList ['a','b','c']) (Arc 0 0.5) ++ queryArc (fastFromList ['j','k','l','m']) (Arc 0.5 1)
~~~

--------------------------------------------------

`outerJoin` flattens the pattern but takes the structure from the outer pattern.

~~~{.ghcisession #outerjoinexample tidalexpression='outerJoin $ fastFromList [ fastFromList [\'a\',\'b\',\'c\'], fastFromList [\'j\',\'k\',\'l\',\'m\'] ]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~

Note that the wholes come from the outer pattern in this case.

--------------------------------------------------

Finally, there's `squeezeJoin`, which compresses each of the inner patterns
into the event they're contained in.

~~~{.ghcisession #squeezejoinexample tidalexpression='squeezeJoin $ fastFromList [ fastFromList [\'a\',\'b\',\'c\'], fastFromList [\'j\',\'k\',\'l\',\'m\'] ]' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
{{tidalexpression}}
~~~


## Manually defining the query function

Since patterns basically only provide a query function, you can write one
yourself instead of using the API we've explored so far.

Here's a degenerate example:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
pat = Pattern { query = \s -> [] }
queryArc pat (Arc 0 1)
queryArc pat (Arc 1 100)
queryArc pat (Arc 7 7)
~~~

(`empty` is defined as `empty = Pattern {query = const []}` in `Pattern.hs`.)

Set the value from the query arc's start time:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
pat = Pattern { query = \(State a ctrls) -> [Event (Context []) (Just a) a (fromRational $ start a :: Double)] }
queryArc pat (Arc 0 1)
queryArc pat (Arc 1 100)
queryArc pat (Arc 7 7)
~~~

Return events whose value is the cycle number:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
:{
pat = Pattern { query = \(State a _) ->
    map
        (\cyclearc -> Event
            (Context [])
            (Just cyclearc)
            (sect a cyclearc)
            (fromRational $ sam $ start cyclearc :: Double))
        (cycleArcsInArc a) }
:}
queryArc pat (Arc 0 3)
queryArc pat (Arc 5 9)
queryArc pat (Arc 7.5 9.5)
~~~

(The `:{` and `:}` lines are for ghci, to have the definition span multiple
lines.)

A pattern with zero events in the zeroth cycle, one event in the first, two
events in the second, etc.:

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
:{
pat = Pattern { query = \s ->
    let
        subpattern :: Int -> Pattern Int
        subpattern = \i -> fast (fromIntegral i) $ pure i
        outterpattern :: Pattern (Pattern Int)
        outterpattern = fromList $ map subpattern [0,1..5]
    in
        query (unwrap outterpattern) s }
:}
queryArc pat (Arc 0 7)
~~~

And so on.

(This last example can be done in a one-liner with `pat = unwrap (fromList $ map (\i -> fast (fromIntegral i) $ pure i) [0,1..5])`;
going through the `query` here is actually unnecessary, but you get the idea)

The part for each event must fit inside its whole.

These functions are executed every time the pattern is queried.  They
shouldn't be computationally expensive so they can be rendered in real time.
Also, it seems that you can't always rely on them being lazily evaluated (there
must be some strictness somewhere).  Using `[0..]` above instead of `[0,1..5]`
hung ghci for me.

You can put a long function expression in a text file with a `.hs` extension
and load it in a ghci session using `:load` and `:reload` (`:l` and `:r`).


## Mini-Notation

So this is sort of the main event.  Tidal includes a "mini-notation" for
succinctly specifying patterns as text strings.  Most of the examples you see
will start with this format.

It's functionality that sits on top of Sound.Tidal.Pattern and
Sound.Tidal.Core, so I felt it was less fundamental and left it until now.
It's defined in `ParseBP.hs`.

So as we saw in 'Starting to look at some expressions' above, expressions like
`s "bd ~ bd ~"` don't work in ghci by default.  You need to add `parseBP_E` or
turn on implicit string handling with `:set -XOverloadedStrings`.  This will be
already turned on in Tidal proper.  For the examples here I'll include
`parseBP_E` explicitly for the sake of understanding and driving the point home.

See <https://tidalcycles.org/docs/patternlib/tutorials/mini_notation> for
further notes on the syntax more examples.

--------------------------------------------------

So the most basic pattern just lists the event values in a string.  They're
compressed into one cycle, like with `fastFromList`.

~~~{.ghcisession #basicpattern tidalexpression='"a b c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

There are some things to note here.  The type of the values is inferred from
the outer type annotation.  To wit:

~~~{.ghcisession tidalexpression='parseBP_E "1 2 3"'}
import Sound.Tidal.Context
--cut>>
:set +t
{{tidalexpression}} :: Pattern Double
{{tidalexpression}} :: Pattern Char
{{tidalexpression}} :: Pattern Int
~~~

If you don't give a type hint, it'll fall back to a default type for the
values.

~~~{.ghcisession}
import Sound.Tidal.Context
:set +t
--cut>>
parseBP_E "e f g"
~~~

If you omit the type hint some characters just don't work.

~~~{.ghcisession}
import Sound.Tidal.Context
:set +t
--cut>>
parseBP_E "j k l" :: Pattern Char
parseBP_E "j k l"
~~~

Also, `drawLine` expects a pattern of type `Pattern Char`.  So you can't use it
to show patterns of strings, for example.

--------------------------------------------------

Onward with more mini-notation.  Tilde is a rest:

~~~{.ghcisession #tildeisarest tidalexpression='"b ~ b ~"' .diagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

So the dot in the `drawLine` output is the rest.

![](tildeisarest.svg)

--------------------------------------------------

Underscore elongates a note:

~~~{.ghcisession #underscoreelongates tidalexpression='"a _ c"' .diagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

The hyphen means that the a note is held for an extra division.

![](underscoreelongates.svg)

--------------------------------------------------

`@` elongates a pattern by some number of counts:

~~~{.ghcisession #atelongates tidalexpression='"a@3 b"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

--------------------------------------------------

Repeat an event with * . Notice how it takes the time the event would have taken and subdivides that:

~~~{.ghcisession #repeateventasterisk tidalexpression='"a*2 c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

So instead of getting the cycle divided into three, it's divided into four.

The 'a' events have duration 1/4.

--------------------------------------------------

Use ! to repeat an event.  Contrast this with * .

~~~{.ghcisession #repeateventbang tidalexpression='"a!2 c"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

The 'a' events have duration 1/3 here.

--------------------------------------------------

Use square brackets for grouping.

~~~{.ghcisession #squarebrackets tidalexpression='"[a b c] [d e]"' .diagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

So it divided the pattern into two halves, and then divided the first half into
three and the second half into two.

![](squarebrackets.svg)

--------------------------------------------------

You can do the same with a dot:

~~~{.ghcisession #thedot tidalexpression='"a b c . d e"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

--------------------------------------------------

So this is where I think it starts to get interesting.
Use a comma to play two patterns in parallel.  Apparently you need the square brackets as well.

~~~{.ghcisession #commaforparallel tidalexpression='"[a b c , d e]"' .diagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

The first expression's output orders the interleaved events by onset time.

![](commaforparallel.svg)

--------------------------------------------------

You can create polymetric sequences with braces:

~~~{.ghcisession #polymetricbraces tidalexpression='"{a b c , d e}"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

So it looks like it takes the first pattern and divides the cycle by the number
of elements it has, and then uses that length for each element of the second
pattern.

Contrast with doing it in the other order:

~~~{.ghcisession #polymetricbracesotherorder tidalexpression='"{d e , a b c}"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

So in this second version, the 'a b c' events have a longer duration:
putting the "d e" first divides the cycle in two, and so the "a b c" pattern
repeats every 1.5 cycles.

The vertical bar in the text output seems to show a one-cycle duration.

--------------------------------------------------

You can set the length of the polymetric sequence with `%`.

This expression divides the cycle into eight

~~~{.ghcisession #polymetricdividebyeight tidalexpression='"{a b c d e}%8"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

This expression divides the cycle into seven.

~~~{.ghcisession #polymetricdividebyseven tidalexpression='"{a b c d e}%7"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

--------------------------------------------------

Use angle brackets to alternate between the events

~~~{.ghcisession #anglebrackets tidalexpression='"<a b c> d <e f>"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

--------------------------------------------------

Use brackets to create a Euclidean rhythm:

~~~{.ghcisession #euclideanrhythm tidalexpression='"a(3,7)"' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
parseBP_E {{tidalexpression}} :: Pattern Char
drawLine $ parseBP_E {{tidalexpression}}
~~~

## Querying events crossing cycle boundaries

Interestingly, querying a `slow 1.5` expression shows that it apparently splits
events at cycle boundaries:

~~~{.ghcisession #slowoneandahalf tidalexpression='slow 1.5 $ fastFromList [\'a\', \'a\', \'b\', \'c\'] :: Pattern Char' .diagram .insertdiagram}
import Sound.Tidal.Context
--cut>>
pat = {{tidalexpression}}
drawLine pat
stripContext = setContext $ Context []
putStrLn $ showAll (Arc 0 3) (stripContext pat)
~~~

(`stripContext` is copied from `TestUtils.hs`.)

Events that straddle a cycle boundary show up as two events with different
parts but the same whole.  For example, we have

 - (¾>1)-1⅛|'b'
 - ¾-(1>1⅛)|'b'

Both events' wholes are the same: (¾>1⅛).

I'm not sure if this is intentional or if it's an artifact of how I'm doing
this.

I don't think it's important in practice since I would assume the scheduler
sends out the event that contains the whole's onset and ignores the other one.
I confirmed using using a Tidal REPL (BootTidal.hs) and `oscdump` that using
`speed 1.5` sends the OSC messages that you'd expect.

The way I found to work around this is to use `defragParts` and `sort`:

~~~{.ghcisession tidalexpression='slow 1.5 $ parseBP_E "a a b c" :: Pattern Char'}
import Sound.Tidal.Context
pat = {{tidalexpression}}
stripContext = setContext $ Context []
--cut>>
import Data.List (sort)
mapM_ print $ sort $ defragParts $ queryArc (stripContext pat) (Arc 0 3)
~~~

## `ControlPattern` and `ValueMap`

Tidal examples often start with something like `s $ "bd sd bd sd"`.  If we look
at its type:

~~~{.ghcisession tidalexpression='s $ parseBP_E "bd sd bd sd"'}
import Sound.Tidal.Context
--cut>>
pat = {{tidalexpression}}
pat
:t pat
~~~

A `ControlPattern` is a pattern that contains events whose values are maps with
key/value pairs.  It is defined in `src/Sound/Tidal/Pattern.hs`

    type ControlPattern = Pattern ValueMap

    type ValueMap = Map.Map String Value

    -- | Polymorphic values
    data Value = VS { svalue :: String   }
               | VF { fvalue :: Double   }
               | VN { nvalue :: Note     }
               ...

So each event in the pattern has a value of type `ValueMap`.  As I understand
it, the idea is that the various keys in the `ValueMap` get inserted into the
outgoing OSC message.  The particular keys to use are defined by SuperDirt, so
this is the point where we need to factor in how SuperDirt works.

From  [`SuperDirt/classes/DirtEvent.sc`](https://github.com/musikinformatik/SuperDirt/blob/master/classes/DirtEvent.sc):

    DirtEvent {
        ...

        play {
            event.parent = orbit.defaultParentEvent;
            event.use {
                // s and n stand for synth/sample and note/number
                ~s ?? { this.splitName };
                ...
        }
        ...
    }

	splitName {
		var s, n;
		#s, n = ~sound.asString.split($:);
		~s = s.asSymbol;
		~n = if(n.notNil) { n.asFloat } { 0.0 };
	}


So the key `s` refers to the synth or sample to use.

`s` is an alias for `sound`.  It's defined in `src/Sound/Tidal/Params.hs`.

    s :: Pattern String -> ControlPattern
    s = sound

    sound :: Pattern String -> ControlPattern
    sound = grp [mS "s", mF "n"]

This is combining a string value with key "s" and a float value with key "n".

`d1 $ s "sd bd hh"` sends this over OSC:

    e56dd4d3.2f855800 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 79.000000 "delta" 0.592592 "orbit" 0 "s" "sd"
    e56dd4d3.c7397800 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 79.333336 "delta" 0.592593 "orbit" 0 "s" "bd"
    e56dd4d4.5eeda000 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 79.666664 "delta" 0.592593 "orbit" 0 "s" "hh"
    e56dd4d4.f6a1c800 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 80.000000 "delta" 0.592593 "orbit" 0 "s" "sd"
    e56dd4d5.8e55f000 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 80.333336 "delta" 0.592592 "orbit" 0 "s" "bd"
    e56dd4d6.260a1000 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 80.666664 "delta" 0.592593 "orbit" 0 "s" "hh"

`d1 $ s "sd sd:1 sd:2 sd:3"` sends this over OSC:

    e56dd58a.4bf71800 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 182.000000 "delta" 0.444445 "orbit" 0 "s" "sd"
    e56dd58a.bdbe3800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 182.250000 "delta" 0.444445 "n" 1.000000 "orbit" 0 "s" "sd"
    e56dd58b.2f855800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 182.500000 "delta" 0.444444 "n" 2.000000 "orbit" 0 "s" "sd"
    e56dd58b.a14c7000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 182.750000 "delta" 0.444445 "n" 3.000000 "orbit" 0 "s" "sd"
    e56dd58c.13139000 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 183.000000 "delta" 0.444444 "orbit" 0 "s" "sd"
    e56dd58c.84daa800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 183.250000 "delta" 0.444445 "n" 1.000000 "orbit" 0 "s" "sd"
    e56dd58c.f6a1c800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 183.500000 "delta" 0.444444 "n" 2.000000 "orbit" 0 "s" "sd"
    e56dd58d.6868e000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 183.750000 "delta" 0.444445 "n" 3.000000 "orbit" 0 "s" "sd"

So for e.g. snare drum samples, there are several snare drums to choose from, and this is cycling through several of them.

## Layering parameter patterns to build up an event stream

So one reason this is interesting is that you can create individual patterns
for several parameters and then combine them into one stream of events.

~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
stripContext = setContext $ Context []
putStrLn $ showAll (Arc 0 3) $ stripContext $ (s $ parseBP_E "bd sd hh") # (slow 3 $ pan $ parseBP_E "0.2 0.5 0.7")
~~~

~~~{.patternalgebraexample #valueAlgebraMapDiagram tidalexpression='(s $ parseBP_E "bd sd hh") # (slow 3 $ pan $ parseBP_E "0.2 0.5 0.7") :: Pattern ValueMap' .diagram .insertdiagram}
~~~

This is a little more succinct to express in Tidal proper.  You can write it as

    tidal> s "bd sd hh" # (slow 3 $ pan "0.2 0.5 0.7")

or

    tidal> s "bd sd hh" # pan "{0.2 0.5 0.7}%1"


## Booting Tidal from ghci

You can actually boot a live Tidal from ghci and get a prompt:

    $ ghci
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    Prelude> :script BootTidal.hs
    [TidalCycles version 1.7.8]
    Installed in /.../.cabal/store/ghc-8.10.7/tdl-1.7.8-5d5b197d/share
    Listening for external controls on 127.0.0.1:6010
    tidal> Waiting for SuperDirt (v.1.7.2 or higher)..

    tidal>
    tidal> s "a b c"
    (0>⅓)|s: "a"
    (⅓>⅔)|s: "b"
    (⅔>1)|s: "c"

Either run `ghci` and then `:script BootTidal.hs`, or run
`ghci -ghci-script BootTidal.hs`.


## Inspecting OSC

You can use `oscdump` from `liblo` to see what messages are coming in:

    $ ./oscdump 57120

Then in the Tidal REPL:

    $ ghci -ghci-script BootTidal.hs
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Loaded package environment from /.../.ghc/x86_64-darwin-8.10.7/environments/default
    [TidalCycles version 1.7.8]
    Installed in /.../.cabal/store/ghc-8.10.7/tdl-1.7.8-5d5b197d/share
    Listening for external controls on 127.0.0.1:6010
    Loaded GHCi configuration from BootTidal.hs
    tidal> Waiting for SuperDirt (v.1.7.2 or higher)..

    tidal>
    tidal> d1 $ s "bd"

You see in the running `oscdump`:

    e520f7d6.950bd000 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 47.000000 "delta" 1.777778 "orbit" 0 "s" "bd"
    e520f7d6.faaf9a8b /dirt/handshake
    e520f7d8.5c284800 /dirt/play sssfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 48.000000 "delta" 1.777778 "orbit" 0 "s" "bd"
    e520f7d8.fae3e6c3 /dirt/handshake


Another example:

    tidal> d1 $ s "bd" + (n "1 2 3")

    in oscdump:
    e520f856.950bd000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 119.000000 "delta" 0.592593 "n" 1.000000 "orbit" 0 "s" "bd"
    e520f857.26c8a372 /dirt/handshake
    e520f857.2cbff800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 119.333336 "delta" 0.592593 "n" 2.000000 "orbit" 0 "s" "bd"
    e520f857.c4742000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 119.666664 "delta" 0.592593 "n" 3.000000 "orbit" 0 "s" "bd"
    e520f858.5c284800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 120.000000 "delta" 0.592592 "n" 1.000000 "orbit" 0 "s" "bd"
    e520f858.f3dc6800 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 120.333336 "delta" 0.592593 "n" 2.000000 "orbit" 0 "s" "bd"
    e520f859.2854de7e /dirt/handshake
    e520f859.8b909000 /dirt/play sssfsfsfsfsiss "_id_" "1" "cps" 0.562500 "cycle" 120.666664 "delta" 0.592593 "n" 3.000000 "orbit" 0 "s" "bd"

So this would be a good way to understand how patterns are played and what's
the result of combining patterns.

Use this to prevent the handshake messages from showing up:

    ./oscdump -L 57120 | grep -v dirt.handshake

## Continuous patterns

Tidal also has continuous patterns, like `sine`:


~~~{.ghcisession}
import Sound.Tidal.Context
--cut>>
queryArc (pan sine) (0 :: Arc)
queryArc (pan sine) (0.1 :: Arc)
queryArc (pan sine) (0.2 :: Arc)
queryArc (pan sine) (0.25 :: Arc)
queryArc (pan sine) (0.5 :: Arc)
queryArc (pan sine) (0.75 :: Arc)
queryArc (pan sine) (1.0 :: Arc)
queryArc (pan sine) (1.25 :: Arc)
queryArc (pan sine) (1.5 :: Arc)
queryArc (pan sine) (1.75 :: Arc)
~~~

So it varies continuously.

`sine` is defined in `src/Sound/Tidal/Core.hs`

These continuous patterns are implemented via `sig` in `Core.hs`

    -- | Takes a function from time to values, and turns it into a 'Pattern'.
    sig :: (Time -> a) -> Pattern a

When you query over an arc, it gives back the entire arc as the event part
extents.  It has no whole.

~~~{.tidalsession}
e = head $ queryArc (pan sine) (Arc 0.5 2)
whole e
part e
value e
~~~

NB: `sig` evaluates the continuous function in the *middle* of the query arc:

~~~{.tidalsession #sigEvaluatesAtMiddle .signalsamplingexample tidalexpression='queryArc (pan sine) (Arc 0.5 0.7)' .diagram .insertdiagram}
{{tidalexpression}}
queryArc (pan sine) (Arc 0.6 0.6)
~~~

### Setting event parameters from a continuous pattern

To take the panning value for each event of a pattern from a
second continuous signal you can do this:

~~~{.tidalsession}
s "a b c d" # pan sine
~~~

It's sampling the sine in the middle of each event.

You can also use the `segment` function to first sample the continuous pattern
before applying it to the notes:

~~~{.tidalsession #sigToSetPanning .signalsetsparameter tidalexpression='s "a b c d" # (pan $ segment 7 sine)' .diagram .insertdiagram}
{{tidalexpression}}
filterEvents eventHasOnset $ {{tidalexpression}}
~~~

I confirmed with `oscdump` that this is effectively only applying the panning
value at each note onset.  The events without onsets don't get sent out over
OSC.

See <http://tidalcycles.org/docs/reference/sampling/#segment> for an example of
`segment` which is similar to this.

## Deconstructing longer expressions

We can use the following to check how the expressions are being parenthesized.

    ghci -ddump-splices -XTemplateHaskell -ghci-script BootTidal.hs
    ...
    tidal> $([| s "1 2 3 4" # pan sine # amp square # speed tri |])
    <interactive>:17:3-55: Splicing expression
        [| s "1 2 3 4" # pan sine # amp square # speed tri |]
      ======>
        (((s "1 2 3 4" # pan sine) # amp square) # speed tri)
    ...

So it looks like (#) is left associative.  Function application always binds
more tightly than operators, so that's why we don't need brackets between the
`#`s.

    tidal> $([| slow 3 $ s "1 2 3 4" # pan sine # amp square # speed tri |])
    <interactive>:24:3-64: Splicing expression
        [| slow 3 $ s "1 2 3 4" # pan sine # amp square # speed tri |]
      ======>
        (slow 3 $ (((s "1 2 3 4" # pan sine) # amp square) # speed tri))
    ...

And using `slow` in this way operates on everything to its right (which I guess
is to be expected due to the `$`).

## `UI.hs`

`UI.hs` contains the higher-level pattern manipulation functions.  I'm not
super interested in documenting all of these, but I'll review a few for
completeness.

"`rand` generates a continuous pattern of (pseudo-)random numbers between `0`
and `1`."

~~~{.tidalsession tidalexpression='sound "bd*8" # pan rand'}
--cut>>
{{tidalexpression}}
~~~

The infamous `jux` takes a function and a pattern; it puts one copy of the
pattern in the left channel, and another copy of the pattern in the right
channel with the function applied.

~~~{.tidalsession #juxexample .spatternexample tidalexpression='jux rev $ s "sd bd oh ch"' .diagram .insertdiagram}
--cut>>
{{tidalexpression}}
~~~

`shuffle` divides a cycle up and randomly permutes the parts.

~~~{.tidalsession #shuffleexample .spatternexample tidalexpression='shuffle 4 $ s "sd bd oh ch"' .diagram .insertdiagram}
--cut>>
{{tidalexpression}}
~~~

There's lots more to explore in `UI.hs`.  It's documented on
[hackage](https://hackage.haskell.org/package/tidal-1.7.9/docs/Sound-Tidal-UI.html).


## `BootTidal.hs`

The `BootTidal.hs` starts up Tidal and sets up several of the convenience
aliases that make it easier to write code live.

`tidal` here refers to the variable that's returned by `startTidal`.

    p = streamReplace tidal
    ...
    hush = streamHush tidal
    mute = streamMute tidal
    unmute = streamUnmute tidal
    ...
    solo = streamSolo tidal
    ...
    setcps = asap . cps
    getcps = streamGetcps tidal
    ...
    d1 = p 1 . (|< orbit 0)
    d2 = p 2 . (|< orbit 1)
    d3 = p 3 . (|< orbit 2)
    ...


## Conclusion

So that's it.  Hopefully that was helpful if you're trying to understand
Tidal's codebase or to use it from ghci.  Now I'm off to make some music!


## See also

Live code with Tidal Cycles | Tidal Cycles<br/>
<https://tidalcycles.org/>

Types in tidal-cycles<br/>
<https://www.imn.htwk-leipzig.de/~waldmann/etc/untutorial/tc/types/>

What is a pattern? - TidalCycles userbase<br/>
<https://userbase.tidalcycles.org/index.php/What_is_a_pattern%3F>

Tidal Adventures. Introduction | by Carsten Heisterkamp | Medium<br/>
<https://heisterkamp.medium.com/tidal-adventures-ab627f05ef7c>

tidal: Pattern language for improvised music<br/>
<https://hackage.haskell.org/package/tidal>



